<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Handbook</title>
    
    <!-- Google Fonts: Inter & Roboto Mono -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Prism.js for Syntax Highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

    <!-- Custom Stylesheet -->
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <button id="sidebar-toggle" aria-label="Toggle Sidebar">â˜°</button>

    <div class="preloader"></div>

    <aside id="sidebar">
        <div class="sidebar-header">
            <h3>Table of Contents</h3>
            <button id="theme-toggle" aria-label="Toggle dark mode">
                <svg class="sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24"><path d="M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.106a.75.75 0 010 1.06l-1.591 1.59a.75.75 0 01-1.06-1.06l1.59-1.59a.75.75 0 011.06 0zM21.75 12a.75.75 0 01-.75.75h-2.25a.75.75 0 010-1.5H21a.75.75 0 01.75.75zM17.894 17.894a.75.75 0 011.06 0l1.59 1.591a.75.75 0 01-1.06 1.06l-1.59-1.59a.75.75 0 010-1.061zM12 18a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0v-2.25A.75.75 0 0112 18zM6.106 17.894a.75.75 0 010-1.06l-1.59-1.591a.75.75 0 01-1.061 1.06l1.59 1.59a.75.75 0 011.06 0zM4.5 12a.75.75 0 01.75-.75h2.25a.75.75 0 010 1.5H5.25a.75.75 0 01-.75-.75zM6.106 6.106a.75.75 0 011.06 0l1.591 1.59a.75.75 0 01-1.06 1.06l-1.59-1.59a.75.75 0 010-1.06z"></path></svg>
                <svg class="moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24"><path fill-rule="evenodd" d="M9.528 1.718a.75.75 0 01.162.819A8.97 8.97 0 009 6a9 9 0 009 9 8.97 8.97 0 004.472-.647.75.75 0 01.818.162A12.73 12.73 0 0118 21a12.75 12.75 0 01-12.75-12.75 12.73 12.73 0 013.228-8.532z" clip-rule="evenodd"></path></svg>
            </button>
        </div>
        <input type="text" id="toc-search" placeholder="Search topics..." aria-label="Search TOC" />
        <nav id="toc-container">
            <!-- Table of Contents will be generated by script.js -->
        </nav>
    </aside>
    
<div id="content-search-container">
    <input type="text" id="content-search" placeholder="Search in content..." aria-label="Search content">
    <span id="search-match-count"></span>
</div>

    <main id="main-content">
        <header>
            <h1>Python Handbook</h1>
            <p class="author">by Aarush Maurya</p>
        </header>

        <section id="introduction">
            <h3 id="how-to-use-this-handbook">How to Use This Handbook</h3>
            <p>This handbook is designed for two primary purposes: as a sequential learning guide for those new to Python, and as a comprehensive reference for experienced developers.</p>
            <p><strong>For Beginners:</strong> It is recommended to proceed through the chapters sequentially, as concepts build upon one another. The detailed explanations are crafted to build a strong foundational understanding. Take the time to run the code examples yourself to see them in action.</p>
            <p><strong>For Experienced Programmers:</strong> Use the Table of Contents and the Index to quickly navigate to specific topics. The detailed explanations can serve as a refresher on nuances and best practices.</p>
        </section>

        <div class="part-heading" id="part-1-the-core-language">Part 1: The Core Language</div>

        <h2 id="chapter-1-getting-started-with-python">Chapter 1: Getting Started with Python</h2>
        <h3 id="why-python">Why Python?</h3>
        <p>Python is a high-level, interpreted, general-purpose programming language. Let's break down what this means:</p>
        <p><strong>High-Level:</strong> Python abstracts away many of the complex, low-level details of the computer, such as memory management. This allows you to focus on the problem you're trying to solve rather than the intricacies of the machine.</p>
        <p><strong>Interpreted:</strong> Code is executed line-by-line by an interpreter. This is different from compiled languages (like C++ or Java), where the entire program is first translated into machine code. This makes the development cycle faster, as you can run code immediately without a compilation step.</p>
        <p><strong>General-Purpose:</strong> Python is not designed for one specific task. Its versatility and vast library support make it a powerful tool for a wide range of applications, including:</p>
        <ul>
        <li>Web Development (e.g., Django, Flask)</li>
        <li>Data Science & Machine Learning (e.g., Pandas, Scikit-learn)</li>
        <li>Automation and Scripting</li>
        <li>Desktop Applications and more.</li>
        </ul>
        <p>Its core design philosophy emphasizes code readability, using significant indentation to structure code blocks, which enforces a clean and consistent coding style.</p>
        <h3 id="setting-up-your-environment">Setting Up Your Environment</h3>
        <p>To write and run Python code, you need two things: the Python interpreter and a place to write your code.</p>
        <p><strong>Install Python:</strong></p>
        <p>Visit the official website: <code>python.org</code>.</p>
        <p>Download the latest stable version for your operating system (Windows, macOS, or Linux).</p>
        <p>During installation (especially on Windows), it is crucial to check the box that says "Add Python to PATH". This allows you to run the Python interpreter from any directory in your terminal or command prompt by simply typing <code>python</code>.</p>
        <p><strong>Choose a Code Editor or IDE:</strong></p>
        <p>While you can write code in a simple text editor, a dedicated code editor or an Integrated Development Environment (IDE) provides features like syntax highlighting, code completion, and debugging tools that will significantly improve your productivity.</p>
        <ul>
        <li><strong>Visual Studio Code (VS Code):</strong> A free, highly popular, and extensible code editor. It is an excellent choice for beginners and professionals alike. You will need to install the official Python extension from its marketplace.</li>
        <li><strong>PyCharm:</strong> A powerful IDE specifically for Python development. It comes in a free "Community" edition and a paid "Professional" edition.</li>
        <li><strong>Sublime Text:</strong> A lightweight and fast code editor known for its performance.</li>
        </ul>
        <h3 id="using-the-python-repl-interactively">Using the Python REPL Interactively</h3>
        <p>The Python REPL (Read-Eval-Print Loop) is an interactive command-line program that allows you to execute Python code one line at a time. It is an invaluable tool for quick experiments, testing syntax, and exploring how functions work without needing to create a file.</p>
        <p>To start the REPL, open your terminal (Command Prompt on Windows, Terminal on macOS/Linux) and type <code>python</code> (or <code>python3</code> on some systems) and press Enter.</p>
        <pre><code class="language-bash">$ python
Python 3.10.4 (...) on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>></code></pre>
        <p>The <code>>>></code> prompt indicates that the REPL is ready to accept a command.</p>
        <ul>
        <li><strong>Read:</strong> It reads the code you type (<code>2 + 5</code>).</li>
        <li><strong>Eval:</strong> It evaluates (executes) the code.</li>
        <li><strong>Print:</strong> It prints the result (<code>7</code>).</li>
        <li><strong>Loop:</strong> It loops back to the beginning, waiting for your next command.</li>
        </ul>
        <pre><code class="language-python">>>> 2 + 5
7
>>> message = "Exploring the REPL"
>>> print(message)
Exploring the REPL</code></pre>
        <p>To exit the REPL, you can type <code>exit()</code> or press Ctrl+D (on macOS/Linux) or Ctrl+Z then Enter (on Windows).</p>
        <h3 id="your-first-python-program">Your First Python Program</h3>
        <p>While the REPL is great for experimenting, most applications are written in <code>.py</code> files.</p>
        <p><strong>Create a File:</strong> Open your code editor (e.g., VS Code) and create a new file. Save it as <code>hello.py</code>. The <code>.py</code> extension is crucial as it identifies the file as a Python script.</p>
        <p><strong>Write the Code:</strong> Type the following line into the file.</p>
        <pre><code class="language-python">print("Hello, World!")</code></pre>
        <ul>
        <li><code>print()</code> is a built-in Python function that outputs text (or other data) to the console.</li>
        <li>The text inside the parentheses is the argument to the function.</li>
        <li><code>"Hello, World!"</code> is a string literal, a sequence of characters enclosed in quotes.</li>
        </ul>
        <p><strong>Run the Script:</strong></p>
        <ol>
        <li>Open your terminal.</li>
        <li>Use the <code>cd</code> (change directory) command to navigate to the folder where you saved <code>hello.py</code>.</li>
        <li>Run the script by typing <code>python hello.py</code> and pressing Enter.</li>
        </ol>
        <pre><code class="language-bash">$ python hello.py
Hello, World!</code></pre>
        <p>The Python interpreter executes the code in the <code>hello.py</code> file, and the <code>print</code> function displays the output in your terminal.</p>
        <h3 id="code-structure-comments">Code Structure & Comments</h3>
        <p>Python's structure is unique because it uses indentation to define code blocks, such as the body of a function, a loop, or a conditional statement. The standard is to use four spaces per indentation level. This is not optional; it is a part of the language's syntax.</p>
        <p>Comments are text in your code that is ignored by the Python interpreter. They are essential for explaining why your code does what it does, making it easier for others (and your future self) to understand.</p>
        <ul>
        <li>Single-line comments begin with a hash symbol (<code>#</code>). Anything from the <code>#</code> to the end of the line is a comment.</li>
        <li>Multi-line comments or docstrings are enclosed in triple quotes (<code>"""..."""</code> or <code>'''...'''</code>). While technically strings, they are often used as multi-line comments. When placed as the first statement in a module, function, or class, they become the object's <code>__doc__</code> attribute, which is used by help systems and documentation generators.</li>
        </ul>
        <pre><code class="language-python"># This entire line is a comment.
# It's good practice to explain complex parts of your code.

def greet(name):
    """
    This is a docstring. It serves as a multi-line comment.
    
    This function takes one argument, 'name', and prints a
    greeting message to the console.
    """
    # The indented block below is the body of the 'greet' function.
    # It will only execute when the function is called.
    message = f"Hello, {name}!" # An inline comment explaining the variable
    print(message)

# This line is not indented, so it is outside the function definition.
greet("World")</code></pre>
        <h2 id="chapter-2-variables-data-types-and-scope">Chapter 2: Variables, Data Types, and Scope</h2>
        <h3 id="variables-and-naming-rules">Variables and Naming Rules</h3>
        <p>In Python, a variable is a name that you give to a memory location where a value is stored. Think of it as a label for a piece of data. Assigning a value is done with the equals sign (<code>=</code>).</p>
        <pre><code class="language-python"># 'user_age' is the variable name, and 30 is the value it references.
user_age = 30

# The value can be changed by reassigning the variable.
user_age = 31</code></pre>
        <p>Python has specific rules for naming variables:</p>
        <ul>
        <li><strong>Must Start with a Letter or Underscore:</strong> A variable name cannot begin with a number. <code>name1</code> is valid, but <code>1name</code> is not.</li>
        <li><strong>Allowed Characters:</strong> After the first character, names can contain letters (a-z, A-Z), numbers (0-9), and underscores (_). No other symbols (like !, @, #, $) are allowed.</li>
        <li><strong>Case-Sensitive:</strong> Python treats uppercase and lowercase letters as distinct. <code>age</code>, <code>Age</code>, and <code>AGE</code> are three different variables.</li>
        <li><strong>No Keywords:</strong> You cannot use Python's reserved keywords (like <code>if</code>, <code>for</code>, <code>def</code>, <code>class</code>, etc.) as variable names.</li>
        </ul>
        <div class="card">
            <h4>Naming Conventions (Best Practices - PEP 8)</h4>
            <p>Variable names should be lowercase, with words separated by underscores to improve readability (this is called <strong>snake_case</strong>).</p>
            <ul>
                <li><strong>Good:</strong> <code>first_name</code>, <code>item_list</code></li>
                <li><strong>Bad:</strong> <code>FirstName</code>, <code>itemlist</code></li>
            </ul>
        </div>
        <pre><code class="language-python"># Valid variable names
first_name = "Aarush"
user_id_123 = "xyz-001"
_internal_variable = True # An underscore prefix often signifies a variable for internal use

# Invalid variable name
# 2_users = ["Alice", "Bob"] # SyntaxError: invalid decimal literal</code></pre>
        <h3 id="core-data-types">Core Data Types</h3>
        <p>Every value in Python has a data type. Python is dynamically typed, which means you don't have to explicitly declare the type of a variable; the interpreter figures it out at runtime. The <code>type()</code> function can be used to check a variable's type.</p>
        <p><strong><code>int</code> (Integer):</strong> Represents whole numbers, both positive and negative, without decimals. Integers in Python can be of any size, limited only by the available memory.</p>
        <pre><code class="language-python">user_count = 150
temperature = -5
print(type(user_count)) # <class 'int'></code></pre>
        <p><strong><code>float</code> (Floating-Point Number):</strong> Represents numbers with a decimal point. They are used for real numbers that require fractional precision.</p>
        <pre><code class="language-python">price = 99.95
pi = 3.14159
print(type(price)) # <class 'float'></code></pre>
        <p><strong><code>str</code> (String):</strong> Represents a sequence of characters. Strings are created by enclosing characters in single quotes (<code>'...'</code>), double quotes (<code>"..."</code>), or triple quotes (<code>"""..."""</code> for multi-line strings).</p>
        <pre><code class="language-python">greeting = "Hello, Python!"
user_name = 'Alice'
multi_line_text = """This is a string
that spans multiple lines."""
print(type(greeting)) # <class 'str'></code></pre>
        <p><strong><code>bool</code> (Boolean):</strong> Represents one of two values: <code>True</code> or <code>False</code>. Booleans are fundamental for control flow and conditional logic. Note the capital T and F.</p>
        <pre><code class="language-python">is_active = True
has_errors = False
print(type(is_active)) # <class 'bool'></code></pre>
        <p><strong><code>NoneType</code> (None):</strong> A special type that has only one value: <code>None</code>. It is used to signify the absence of a value or a null value. It is not the same as <code>0</code>, <code>False</code>, or an empty string. Functions that don't explicitly return a value implicitly return <code>None</code>.</p>
        <pre><code class="language-python">winner = None # The winner has not been determined yet
print(type(winner)) # <class 'NoneType'></code></pre>
        <h3 id="mutability-vs-immutability">Mutability vs. Immutability</h3>
        <p>This is a fundamental concept in Python that determines whether an object's value can be changed after it is created.</p>
        <p><strong>Immutable</strong> objects cannot be changed after creation. Any operation that appears to modify an immutable object actually creates a new object in memory.</p>
        <ul><li><strong>Types:</strong> <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, <code>tuple</code>.</li><li><strong>Implication:</strong> This makes them safe to use as dictionary keys because their hash value will never change.</li></ul>
        <pre><code class="language-python">my_string = "hello"
# The following line will raise a TypeError because strings are immutable.
# my_string[0] = "H" 

# This doesn't change the original string; it creates a new one.
new_string = my_string.upper() 
print(my_string)   # Output: hello
print(new_string)  # Output: HELLO</code></pre>
        <p><strong>Mutable</strong> objects can be changed in place after they are created, without reassigning the variable.</p>
        <ul><li><strong>Types:</strong> <code>list</code>, <code>dict</code>, <code>set</code>.</li><li><strong>Implication:</strong> If you pass a mutable object to a function, that function can modify the original object. This can be powerful but also a source of bugs if not handled carefully.</li></ul>
        <pre><code class="language-python">my_list = [1, 2, 3]
print(f"Original list: {my_list}")

# Modify the list in place
my_list.append(4) 
my_list[0] = 100

print(f"Modified list: {my_list}") # Output: Modified list: [100, 2, 3, 4]</code></pre>
        <h3 id="scope-global-and-nonlocal-keywords">Scope: global and nonlocal Keywords</h3>
        <p>Scope refers to the region of a program where a variable is accessible. Python has a few levels of scope, commonly remembered as LEGB (Local, Enclosing, Global, Built-in).</p>
        <p>The <code>global</code> keyword is used when you are inside a function and want to modify a variable that was defined in the main body (global scope) of your script. Without <code>global</code>, assigning a value to a variable inside a function creates a new local variable.</p>
        <pre><code class="language-python">count = 0 # This is a global variable

def increment_global():
    global count # Declare that we intend to modify the global 'count'
    count += 1
    print(f"Inside function: {count}")

increment_global()
print(f"Outside function: {count}")
# Output:
# Inside function: 1
# Outside function: 1</code></pre>
        <p>The <code>nonlocal</code> keyword is used in nested functions. It allows an inner function to modify a variable from its direct enclosing function's scope (not the global scope).</p>
        <pre><code class="language-python">def counter_factory():
    num = 0 # This variable is in the enclosing scope
    def increment_local():
        nonlocal num # Declare intent to modify 'num' from the enclosing scope
        num += 1
        return num
    return increment_local

# 'inc' becomes the 'increment_local' function, "remembering" its 'num' variable
inc = counter_factory()
print(inc()) # Output: 1
print(inc()) # Output: 2</code></pre>
        <h3 id="type-hinting">Type Hinting</h3>
        <p>Introduced in Python 3.5, type hints are a way to statically indicate the type of a variable or a function's arguments and return value. Python remains dynamically typed; these are only hints and are not enforced at runtime. However, they offer significant benefits:</p>
        <ul>
            <li><strong>Improved Readability:</strong> They make code self-documenting.</li>
            <li><strong>Static Analysis:</strong> Tools like <code>mypy</code> can check your code for type consistency before you run it, catching a whole class of potential bugs.</li>
        </ul>
        <p>The syntax for a variable is <code>variable_name: type</code>. For functions, it's <code>def func(param: type) -> return_type:</code>.</p>
        <pre><code class="language-python">from typing import List, Optional, Union

# A variable that can be a string or None
name: Optional[str] = "Alice"
name = None # This is valid according to the type hint

# A variable that can be an integer or a string
user_id: Union[int, str] = 123
user_id = "user-abc" # This is also valid

# A function with type hints for parameters and return value
def calculate_average(numbers: List[float]) -> float:
    """Calculates the average of a list of floats."""
    if not numbers:
        return 0.0
    return sum(numbers) / len(numbers)

# Calling the function with the correct type
result = calculate_average([10.5, 20.0, 15.5])
print(result) # Output: 15.333...</code></pre>

        <h2 id="chapter-3-operators-in-python">Chapter 3: Operators in Python</h2>
        <p>Operators are special symbols in Python that carry out arithmetic or logical computation.</p>
        <h3 id="arithmetic-and-assignment-operators">Arithmetic and Assignment Operators</h3>
        <p><strong>Arithmetic Operators</strong> perform mathematical calculations.</p>
        <ul>
        <li><code>+</code> (Addition), <code>-</code> (Subtraction), <code>*</code> (Multiplication)</li>
        <li><code>/</code> (True Division): Always results in a float. <code>10 / 4</code> is <code>2.5</code>.</li>
        <li><code>//</code> (Floor Division): Divides and rounds down to the nearest integer. <code>10 // 4</code> is <code>2</code>.</li>
        <li><code>%</code> (Modulo): Returns the remainder of a division. <code>10 % 4</code> is <code>2</code>.</li>
        <li><code>**</code> (Exponentiation): Raises to a power. <code>2 ** 4</code> is <code>16</code>.</li>
        </ul>
        <p><strong>Assignment Operators</strong> are shortcuts to update a variable's value.</p>
        <ul>
        <li><code>=</code> (Simple Assignment)</li>
        <li><code>+=</code>, <code>-=</code>, <code>*=</code>, etc. combine an arithmetic operation with assignment.</li>
        </ul>
        <pre><code class="language-python">wallet = 50
price = 15

# This line is equivalent to: wallet = wallet - price
wallet -= price 

print(f"Remaining balance: ${wallet}") # Output: Remaining balance: $35</code></pre>
        <h3 id="comparison-and-logical-operators">Comparison and Logical Operators</h3>
        <p>These operators are the foundation of decision-making in code. They evaluate to a boolean value (<code>True</code> or <code>False</code>).</p>
        <p><strong>Comparison Operators</strong> compare two values.</p>
        <ul>
        <li><code>==</code> (Equal to)</li>
        <li><code>!=</code> (Not equal to)</li>
        <li><code>></code> (Greater than)</li>
        <li><code><</code> (Less than)</li>
        <li><code>>=</code> (Greater than or equal to)</li>
        <li><code><=</code> (Less than or equal to)</li>
        </ul>
        <p><strong>Logical Operators</strong> combine boolean expressions.</p>
        <ul>
        <li><code>and</code>: Returns <code>True</code> only if both expressions are true.</li>
        <li><code>or</code>: Returns <code>True</code> if at least one expression is true.</li>
        <li><code>not</code>: Reverses the boolean value (<code>not True</code> is <code>False</code>).</li>
        </ul>
        <pre><code class="language-python">age = 22
has_license = True

# Example 1: Check if the person is an adult driver
is_adult_driver = age >= 18 and has_license
print(f"Is adult driver? {is_adult_driver}") # Output: Is adult driver? True

# Example 2: Check for entry conditions
is_vip = False
has_ticket = True
can_enter = has_ticket or is_vip
print(f"Can enter? {can_enter}") # Output: Can enter? True</code></pre>
        <h3 id="dictionary-merge--update-operators">Dictionary Merge & Update Operators</h3>
        <p>Introduced in Python 3.9, these operators provide a clean and readable syntax for combining dictionaries.</p>
        <p><strong><code>|</code> (Merge Operator):</strong> Creates a new dictionary by merging two. If there are overlapping keys, the value from the dictionary on the right-hand side takes precedence. The original dictionaries are not modified.</p>
        <pre><code class="language-python">default_settings = {'theme': 'dark', 'font_size': 12, 'language': 'en'}
user_settings = {'font_size': 14, 'show_sidebar': True}

# Create a new dictionary with the final settings
final_settings = default_settings | user_settings

print(f"Final settings: {final_settings}")
# Output: Final settings: {'theme': 'dark', 'font_size': 14, 'language': 'en', 'show_sidebar': True}
print(f"Original defaults: {default_settings}") # Unchanged</code></pre>
        <p><strong><code>|=</code> (Update Operator):</strong> Updates a dictionary in place with the key-value pairs from another. This modifies the dictionary on the left-hand side.</p>
        <pre><code class="language-python">config = {'server': 'localhost', 'port': 8080}
updates = {'port': 9000, 'timeout': 30}

# Update the 'config' dictionary in place
config |= updates

print(f"Updated config: {config}")
# Output: Updated config: {'server': 'localhost', 'port': 9000, 'timeout': 30}</code></pre>
        <h2 id="chapter-4-strings-in-depth">Chapter 4: Strings in Depth</h2>
        <p>A string (<code>str</code>) is one of the most commonly used data types in any programming language. In Python, a string is an immutable sequence of characters. "Immutable" means that once a string is created, it cannot be changed. Functions and methods that appear to modify a string actually return a new, modified string, leaving the original untouched.</p>
        <h3 id="creating-and-slicing-strings">Creating and Slicing Strings</h3>
        <p>Strings can be created using single (<code>'</code>), double (<code>"</code>), or triple (<code>"""</code> or <code>'''</code>) quotes. Triple quotes are particularly useful for creating strings that span multiple lines.</p>
        <pre><code class="language-python">single_quoted = 'This is a string.'
double_quoted = "This is also a string."
multi_line = """This string
can span across
multiple lines."""</code></pre>
        <p>Because strings are sequences, you can access individual characters using indexing (starting from 0) and subsequences using slicing.</p>
        <p><strong>Slicing syntax:</strong> <code>my_string[start:stop:step]</code></p>
        <ul>
        <li><code>start</code>: The index where the slice begins (inclusive). If omitted, it defaults to the beginning of the string.</li>
        <li><code>stop</code>: The index where the slice ends (exclusive). If omitted, it defaults to the end of the string.</li>
        <li><code>step</code>: The amount to "step" between characters. If omitted, it defaults to 1. A negative step, like -1, reverses the string.</li>
        </ul>
        <pre><code class="language-python">my_string = "Python Programming"

# Indexing (accessing a single character)
print(f"First character: {my_string[0]}")     # Output: P
print(f"Last character: {my_string[-1]}")     # Output: g (negative indexing starts from the end)

# Slicing
# Get the word "Python"
print(f"Slice [0:6]: {my_string[0:6]}")       # Output: Python
# Get the word "Programming"
print(f"Slice [7:]: {my_string[7:]}")         # Output: Programming
# Get the first 6 characters (same as [0:6])
print(f"Slice [:6]: {my_string[:6]}")         # Output: Python

# Slicing with a step
# Get every second character from the whole string
print(f"Slice [::2]: {my_string[::2]}")       # Output: Pto rgamn
# Reverse the string
print(f"Slice [::-1]: {my_string[::-1]}")     # Output: gnimmargorP nohtyP</code></pre>
        <h3 id="comprehensive-string-methods">Comprehensive String Methods</h3>
        <p>String methods are functions that belong to string objects. They perform common operations and always return a new string.</p>
        <p><strong>Case Conversion Methods:</strong></p>
        <ul>
        <li><code>.lower()</code>: Returns a copy of the string with all characters converted to lowercase.</li>
        <li><code>.upper()</code>: Returns a copy with all characters converted to uppercase.</li>
        <li><code>.capitalize()</code>: Returns a copy with the first character capitalized and the rest lowercase.</li>
        <li><code>.title()</code>: Returns a copy with the first character of each word capitalized.</li>
        <li><code>.swapcase()</code>: Returns a copy with uppercase characters converted to lowercase and vice-versa.</li>
        </ul>
        <pre><code class="language-python">text = "pyThoN is FUN"
print(f"lower: {text.lower()}")         # Output: python is fun
print(f"upper: {text.upper()}")         # Output: PYTHON IS FUN
print(f"capitalize: {text.capitalize()}") # Output: Python is fun
print(f"title: {text.title()}")         # Output: Python Is Fun
print(f"swapcase: {text.swapcase()}")     # Output: PYtHOn IS fun</code></pre>
        <p><strong>Whitespace Stripping Methods:</strong></p>
        <ul>
        <li><code>.strip()</code>: Removes leading (start) and trailing (end) whitespace characters (spaces, tabs, newlines).</li>
        <li><code>.lstrip()</code>: Removes leading whitespace only.</li>
        <li><code>.rstrip()</code>: Removes trailing whitespace only.</li>
        </ul>
        <pre><code class="language-python">user_input = "   admin@example.com   \n"
cleaned_input = user_input.strip()
print(f"'{user_input}' becomes '{cleaned_input}'")
# Output: '   admin@example.com   \n' becomes 'admin@example.com'</code></pre>
        <p><strong>Splitting and Joining Methods:</strong></p>
        <ul>
        <li><code>.split(separator)</code>: Splits the string into a list of substrings, using <code>separator</code> as the delimiter. If no separator is specified, it splits on any whitespace.</li>
        <li><code>separator.join(iterable)</code>: Joins the elements of an iterable (like a list) into a single string, with <code>separator</code> placed between each element.</li>
        </ul>
        <pre><code class="language-python">csv_data = "John,Doe,45,Engineer"
user_list = csv_data.split(',')
print(f"Split data: {user_list}") # Output: ['John', 'Doe', '45', 'Engineer']

words = ["Python", "is", "a", "powerful", "language"]
sentence = " ".join(words)
print(f"Joined sentence: {sentence}") # Output: Python is a powerful language</code></pre>
        <p><strong>Finding and Replacing Methods:</strong></p>
        <ul>
        <li><code>.find(sub)</code>: Returns the lowest index of the substring <code>sub</code>. Returns -1 if not found.</li>
        <li><code>.replace(old, new)</code>: Returns a new string where all occurrences of <code>old</code> are replaced with <code>new</code>.</li>
        <li><code>.startswith(prefix)</code>: Returns <code>True</code> if the string starts with <code>prefix</code>, otherwise <code>False</code>.</li>
        <li><code>.endswith(suffix)</code>: Returns <code>True</code> if the string ends with <code>suffix</code>, otherwise <code>False</code>.</li>
        </ul>
        <pre><code class="language-python">filename = "document_01.pdf"
print(f"Starts with 'doc': {filename.startswith('doc')}") # Output: True
print(f"Ends with '.txt': {filename.endswith('.txt')}") # Output: False

report = "Status: OK. All systems are OK."
fixed_report = report.replace("OK", "OPERATIONAL")
print(fixed_report) # Output: Status: OPERATIONAL. All systems are OPERATIONAL.</code></pre>
        <p><strong>Character Type Checking Methods:</strong></p>
        <p>These methods return <code>True</code> or <code>False</code> and are useful for validating user input.</p>
        <ul>
        <li><code>.isalpha()</code>: <code>True</code> if all characters are alphabetic.</li>
        <li><code>.isdigit()</code>: <code>True</code> if all characters are digits.</li>
        <li><code>.isalnum()</code>: <code>True</code> if all characters are alphanumeric (letters or numbers).</li>
        <li><code>.isspace()</code>: <code>True</code> if all characters are whitespace.</li>
        </ul>
        <pre><code class="language-python">print(f"'Python'.isalpha(): {'Python'.isalpha()}") # Output: True
print(f"'12345'.isdigit(): {'12345'.isdigit()}")   # Output: True
print(f"'User123'.isalnum(): {'User123'.isalnum()}") # Output: True
print(f"'User 123'.isalnum(): {'User 123'.isalnum()}") # Output: False (due to space)</code></pre>
        <h3 id="modern-string-formatting-with-f-strings">Modern String Formatting with f-strings</h3>
        <p>Introduced in Python 3.6, f-strings (formatted string literals) provide the most modern, readable, and efficient way to embed expressions inside string literals. To create an f-string, prefix the string with the letter <code>f</code> or <code>F</code>.</p>
        <p>You can place any valid Python expression inside curly braces <code>{}</code>.</p>
        <pre><code class="language-python">name = "Alice"
age = 30
# Basic embedding of variables
print(f"Her name is {name} and she is {age} years old.")

# Embedding expressions
print(f"In 5 years, she will be {age + 5}.")

# Embedding method calls
print(f"Her name in uppercase is {name.upper()}.")

# Formatting numbers
price = 49.95
tax = 0.07
total = price * (1 + tax)
# Format the total to 2 decimal places
print(f"Total price: ${total:.2f}") # Output: Total price: $53.45</code></pre>

        <h2 id="chapter-5-data-structures-lists-and-tuples">Chapter 5: Data Structures: Lists and Tuples</h2>
        <h3 id="lists-mutable-sequences">Lists: Mutable Sequences</h3>
        <p>A list is an ordered and mutable collection of items. "Ordered" means that items maintain their position, and "mutable" means you can change the list after it has been created (add, remove, or change items). Lists are defined with square brackets <code>[]</code>.</p>
        <pre><code class="language-python"># A list can contain items of different data types
my_list = [1, "apple", True, 3.14, None]
empty_list = []</code></pre>
        <p>Lists support indexing and slicing, just like strings.</p>
        <h3 id="comprehensive-list-methods">Comprehensive List Methods</h3>
        <p>Because lists are mutable, most of their methods modify the list in place and do not return a new list.</p>
        <p><strong><code>.append(item)</code>:</strong> Adds a single item to the end of the list. This is one of the most common list operations.</p>
        <pre><code class="language-python">fruits = ["apple", "banana"]
fruits.append("cherry")
print(fruits) # Output: ['apple', 'banana', 'cherry']</code></pre>
        <p><strong><code>.extend(iterable)</code>:</strong> Appends all items from an iterable (like another list or a tuple) to the end.</p>
        <pre><code class="language-python">more_fruits = ["orange", "mango"]
fruits.extend(more_fruits)
print(fruits) # Output: ['apple', 'banana', 'cherry', 'orange', 'mango']</code></pre>
        <p><strong><code>.insert(index, item)</code>:</strong> Inserts an item at a specific index, shifting other elements to the right.</p>
        <pre><code class="language-python">fruits.insert(1, "blueberry")
print(fruits) # Output: ['apple', 'blueberry', 'banana', 'cherry', 'orange', 'mango']</code></pre>
        <p><strong><code>.remove(item)</code>:</strong> Removes the first occurrence of a specific item. Raises a <code>ValueError</code> if the item is not found.</p>
        <pre><code class="language-python">fruits.remove("banana")
print(fruits) # Output: ['apple', 'blueberry', 'cherry', 'orange', 'mango']</code></pre>
        <p><strong><code>.pop(index=-1)</code>:</strong> Removes and returns the item at a given index. If no index is specified, it removes and returns the last item.</p>
        <pre><code class="language-python">last_fruit = fruits.pop()
print(f"Removed fruit: {last_fruit}") # Output: Removed fruit: mango
print(f"List now: {fruits}")          # Output: List now: ['apple', 'blueberry', 'cherry', 'orange']</code></pre>
        <p><strong>Other Methods:</strong></p>
        <ul>
        <li><code>.clear()</code>: Removes all items from the list, making it empty.</li>
        <li><code>.index(item)</code>: Returns the index of the first occurrence of an item. Raises a <code>ValueError</code> if not found.</li>
        <li><code>.count(item)</code>: Returns the number of times an item appears in the list.</li>
        <li><code>.sort()</code>: Sorts the list in place. By default, it sorts in ascending order.</li>
        <li><code>.reverse()</code>: Reverses the order of elements in the list in place.</li>
        </ul>
        <pre><code class="language-python">numbers = [4, 1, 7, 3, 1]
print(f"Count of 1: {numbers.count(1)}") # Output: 2

numbers.sort() # Sorts in place
print(f"Sorted: {numbers}") # Output: [1, 1, 3, 4, 7]

numbers.reverse() # Reverses in place
print(f"Reversed: {numbers}") # Output: [7, 4, 3, 1, 1]</code></pre>
        <h3 id="tuples-immutable-sequences">Tuples: Immutable Sequences</h3>
        <p>A tuple is an ordered and immutable collection of items. Once a tuple is created, you cannot add, remove, or change its elements. They are defined with parentheses <code>()</code>.</p>
        <pre><code class="language-python">my_tuple = (1, "apple", True)
# my_tuple[0] = 100 # This will raise a TypeError</code></pre>
        <p><strong>Key Characteristics:</strong></p>
        <ul>
        <li><strong>Immutability:</strong> Makes them predictable and safe to use as dictionary keys.</li>
        <li><strong>Performance:</strong> Tuples can be slightly more memory-efficient and faster to iterate over than lists.</li>
        </ul>
        <p><strong>Creating a single-item tuple:</strong> A trailing comma is required to distinguish it from a mathematical expression in parentheses.</p>
        <pre><code class="language-python">not_a_tuple = (1)   # This is just the integer 1
is_a_tuple = (1,)   # The comma makes this a tuple</code></pre>
        <p><strong>Methods:</strong> Tuples have only two methods: <code>.count(item)</code> and <code>.index(item)</code>.</p>
        <p>Tuples are commonly used for fixed collections of items, such as coordinates (x, y), RGB color values (255, 0, 0), or for returning multiple values from a function.</p>
		        <h2 id="chapter-6-data-structures-dictionaries-and-sets">Chapter 6: Data Structures: Dictionaries and Sets</h2>
        <h3 id="dictionaries-key-value-pairs">Dictionaries: Key-Value Pairs</h3>
        <p>A dictionary (<code>dict</code>) is a mutable, unordered (in Python versions before 3.7) collection of key-value pairs. Each key must be unique and of an immutable type (like a string, number, or tuple). As of Python 3.7, dictionaries maintain insertion order. They are defined with curly braces <code>{}</code>.</p>
        <p>Dictionaries are highly optimized for retrieving a value when you know its key.</p>
        <pre><code class="language-python"># A dictionary representing a user
user = {
    "username": "alice123",
    "email": "alice@example.com",
    "age": 30,
    "is_active": True
}</code></pre>
        <p><strong>Accessing Data:</strong></p>
        <ul>
        <li><strong>Using square brackets <code>[]</code>:</strong> This is the direct way to access a value. If the key does not exist, it will raise a <code>KeyError</code>.</li>
        <li><strong>Using the <code>.get(key, default=None)</code> method:</strong> This is a safer way. If the key does not exist, it returns <code>None</code> (or a specified default value) instead of raising an error.</li>
        </ul>
        <pre><code class="language-python">print(user["email"])                    # Output: alice@example.com
# print(user["last_login"])             # This would raise a KeyError

print(user.get("age"))                  # Output: 30
print(user.get("last_login"))           # Output: None (no error)
print(user.get("last_login", "Never"))  # Output: Never (custom default)</code></pre>
        <p><strong>Modifying a Dictionary:</strong></p>
        <p>You can add a new key-value pair or change an existing value using simple assignment.</p>
        <pre><code class="language-python"># Change an existing value
user["email"] = "alice.doe@example.com"

# Add a new key-value pair
user["city"] = "New York"

print(user)</code></pre>
        <h3 id="comprehensive-dictionary-methods">Comprehensive Dictionary Methods</h3>
        <ul>
        <li><code>.keys()</code>: Returns a view object displaying a list of all the keys.</li>
        <li><code>.values()</code>: Returns a view object displaying a list of all the values.</li>
        <li><code>.items()</code>: Returns a view object displaying a list of key-value tuple pairs. This is very useful for iterating over a dictionary.</li>
        </ul>
        <pre><code class="language-python">for key, value in user.items():
    print(f"{key.title()}: {value}")</code></pre>
        <ul>
        <li><code>.pop(key)</code>: Removes the specified key and returns its corresponding value. Raises a <code>KeyError</code> if the key is not found.</li>
        <li><code>.popitem()</code>: Removes and returns the last inserted key-value pair as a tuple.</li>
        <li><code>.update(other_dict)</code>: Updates the dictionary with the key-value pairs from another dictionary or iterable. Existing keys are overwritten.</li>
        </ul>
        <h3 id="sets-unordered-unique-collections">Sets: Unordered, Unique Collections</h3>
        <p>A set is an unordered, mutable collection of unique, hashable items. "Unordered" means they don't maintain any specific position, and "unique" means no duplicate elements are allowed. Sets are defined with curly braces <code>{}</code> or the <code>set()</code> function.</p>
        <pre><code class="language-python"># Creating a set from a list automatically removes duplicates
numbers = [1, 2, 2, 3, 4, 3, 5]
unique_numbers = set(numbers)
print(unique_numbers) # Output: {1, 2, 3, 4, 5}

# To create an empty set, you MUST use set(), not {}
empty_set = set() 
# empty_dict = {} # This creates an empty dictionary</code></pre>
        <p>The primary use case for sets is highly efficient membership testing (<code>in</code>) and performing mathematical set operations.</p>
        <h3 id="comprehensive-set-operations">Comprehensive Set Operations</h3>
        <ul>
        <li><code>.add(item)</code>: Adds an element to the set.</li>
        <li><code>.remove(item)</code>: Removes an element. Raises a <code>KeyError</code> if the element is not found.</li>
        <li><code>.discard(item)</code>: Removes an element if it is present. Does nothing if the element is not found (no error).</li>
        <li><code>.pop()</code>: Removes and returns an arbitrary element from the set.</li>
        </ul>
        <p><strong>Mathematical Set Operations:</strong></p>
        <p>These operations create and return a new set.</p>
        <ul>
        <li><strong>Union</strong> (<code>|</code> or <code>.union()</code>): All elements from both sets.</li>
        <li><strong>Intersection</strong> (<code>&</code> or <code>.intersection()</code>): Elements that are present in both sets.</li>
        <li><strong>Difference</strong> (<code>-</code> or <code>.difference()</code>): Elements in the first set but not in the second.</li>
        <li><strong>Symmetric Difference</strong> (<code>^</code> or <code>.symmetric_difference()</code>): Elements in either set, but not in both.</li>
        </ul>
        <pre><code class="language-python">admins = {"alice", "bob", "charlie"}
moderators = {"charlie", "david", "eve"}

# Who has any kind of permission? (Union)
all_staff = admins | moderators
print(f"All staff: {all_staff}")
# Output: {'bob', 'david', 'charlie', 'eve', 'alice'}

# Who is both an admin and a moderator? (Intersection)
admin_mods = admins & moderators
print(f"Admin and Moderator: {admin_mods}")
# Output: {'charlie'}

# Who is an admin but not a moderator? (Difference)
only_admins = admins - moderators
print(f"Only Admins: {only_admins}")
# Output: {'bob', 'alice'}</code></pre>

        <h2 id="chapter-7-control-flow">Chapter 7: Control Flow</h2>
        <p>Control flow statements are the constructs that allow you to dictate the order in which the statements in your program are executed. Instead of just running from top to bottom, you can make decisions and repeat actions, which is the essence of programming logic.</p>
        <h3 id="conditional-statements-if-elif-else">Conditional Statements: if, elif, else</h3>
        <p>Conditional statements allow your program to execute certain blocks of code only if a specific condition is met.</p>
        <ul>
        <li><strong><code>if</code></strong>: The <code>if</code> statement starts a conditional block. The code inside it only runs if the condition evaluates to <code>True</code>.</li>
        <li><strong><code>elif</code></strong>: Short for "else if," this statement allows you to check for multiple alternative conditions. You can have any number of <code>elif</code> blocks after an <code>if</code>. An <code>elif</code> block only runs if its condition is <code>True</code> and all preceding <code>if</code> and <code>elif</code> conditions were <code>False</code>.</li>
        <li><strong><code>else</code></strong>: This is an optional final block that runs if all preceding <code>if</code> and <code>elif</code> conditions were <code>False</code>.</li>
        </ul>
        <pre><code class="language-python"># Example: Assigning a grade based on a score
score = 85

if score >= 90:
    grade = "A"
    print("Excellent work!")
elif score >= 80:
    grade = "B"
    print("Good job.")
elif score >= 70:
    grade = "C"
    print("Satisfactory.")
else:
    grade = "D"
    print("Needs improvement.")

print(f"The final score is {score}, which is a grade of '{grade}'.")
# Output:
# Good job.
# The final score is 85, which is a grade of 'B'.</code></pre>
        <p>Python considers many values to be "truthy" or "falsy" in a boolean context.</p>
        <ul>
        <li><strong>Falsy values:</strong> <code>False</code>, <code>None</code>, <code>0</code> (for any numeric type), empty sequences (<code>[]</code>, <code>()</code>, <code>""</code>), and empty mappings (<code>{}</code>).</li>
        <li><strong>Truthy values:</strong> Everything else.</li>
        </ul>
        <p>This allows for concise checks:</p>
        <pre><code class="language-python">my_list = []
if my_list:
    print("The list is not empty.")
else:
    print("The list is empty.") # This will be printed</code></pre>
        <h3 id="the-match-statement-pattern-matching">The match Statement (Pattern Matching)</h3>
        <p>Introduced in Python 3.10, the <code>match</code> statement is a powerful control flow structure that compares a value against one or more patterns, known as "cases." It is similar to a <code>switch</code> statement in other languages but far more versatile.</p>
        <p>The <code>match</code> statement takes a subject value and compares it to the pattern in each <code>case</code> block from top to bottom. The first case that matches is executed.</p>
        <ul>
        <li><strong>Literal Patterns:</strong> Match exact values.</li>
        <li><strong>Capture Patterns:</strong> A variable name captures the subject's value.</li>
        <li><strong>Wildcard Pattern (<code>_</code>):</strong> A special case that always matches but doesn't bind the value. It's used as a catch-all, similar to an <code>else</code> block.</li>
        </ul>
        <pre><code class="language-python">def http_status_description(status_code):
    match status_code:
        case 200 | 201: # You can combine literals with | (OR)
            return "OK / Created"
        case 404:
            return "Not Found"
        case 500:
            return "Internal Server Error"
        case status if 400 <= status < 500: # Using a guard condition
            return f"Client Error: {status}"
        case _: # Wildcard for any other value
            return "Unknown status code"

print(http_status_description(200)) # Output: OK / Created
print(http_status_description(403)) # Output: Client Error: 403
print(http_status_description(999)) # Output: Unknown status code</code></pre>
        <h3 id="for-and-while-loops">for and while Loops</h3>
        <p>Loops are used to execute a block of code repeatedly.</p>
        <h4>for Loops</h4>
        <p>A <code>for</code> loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string) or other iterable objects.</p>
        <pre><code class="language-python"># Iterating over a list
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit.capitalize())

# Iterating over a string
for char in "Python":
    print(char, end=" ") # Output: P y t h o n 

# Using the range() function
# range(stop) generates numbers from 0 up to (but not including) stop
for i in range(5):
    print(i) # Output: 0, 1, 2, 3, 4

# range(start, stop, step) provides more control
for i in range(2, 11, 2):
    print(i) # Output: 2, 4, 6, 8, 10</code></pre>
        <h4>while Loops</h4>
        <p>A <code>while</code> loop executes a block of code as long as a specified condition remains <code>True</code>. It's important to ensure the condition will eventually become <code>False</code>; otherwise, you will create an infinite loop.</p>
        <pre><code class="language-python"># A simple countdown
count = 5
while count > 0:
    print(f"{count}...")
    count -= 1  # This modification is crucial to avoid an infinite loop
print("Liftoff!")</code></pre>
        <h3 id="loop-control-break-continue-pass-and-the-else-block">Loop Control (break, continue, pass) and the else Block</h3>
        <p>You can change a loop's execution from its normal sequence.</p>
        <ul>
        <li><strong><code>break</code>:</strong> Immediately terminates the entire loop. Execution continues at the first statement after the loop block.</li>
        <li><strong><code>continue</code>:</strong> Immediately terminates the current iteration and proceeds to the next iteration of the loop.</li>
        <li><strong><code>pass</code>:</strong> A null statement. It does nothing and is used as a placeholder where code is syntactically required but no action is needed.</li>
        </ul>
        <pre><code class="language-python">for num in range(1, 11):
    if num % 2 != 0:
        continue  # Skip odd numbers
    if num > 8:
        break     # Exit the loop if the number is greater than 8
    print(num) # This will only print even numbers up to 8
# Output: 2, 4, 6, 8</code></pre>
        <h4>The else Block in Loops</h4>
        <p>Both <code>for</code> and <code>while</code> loops can have an optional <code>else</code> block. The code in the <code>else</code> block is executed only if the loop completes its entire sequence without being terminated by a <code>break</code> statement. This is useful for running code after a successful search.</p>
        <pre><code class="language-python"># Searching for a prime number
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(f"{n} equals {x} * {n//x}")
            break # Break out of the inner loop
    else:
        # Loop fell through without finding a factor
        print(f"{n} is a prime number")</code></pre>
		        <h2 id="chapter-8-functions">Chapter 8: Functions</h2>
        <p>A function is a named, reusable block of code that performs a specific, well-defined task. Functions help organize code into logical chunks, improve readability, and reduce repetition.</p>
        <h3 id="defining-and-calling-functions">Defining and Calling Functions</h3>
        <p>You define a function using the <code>def</code> keyword, followed by the function name, parentheses <code>()</code>, and a colon <code>:</code>. The code block within the function is indented.</p>
        <pre><code class="language-python"># Defining the function
def greet(name, greeting="Hello"):
    """
    Greets a person with an optional greeting.
    'name' is a required parameter.
    'greeting' is an optional parameter with a default value.
    """
    message = f"{greeting}, {name}!"
    return message

# Calling the function
welcome_message = greet("Alice")
print(welcome_message) # Output: Hello, Alice!

special_greeting = greet("Bob", greeting="Good morning")
print(special_greeting) # Output: Good morning, Bob!</code></pre>
        <ul>
        <li><strong>Parameters</strong> are the variable names listed in the function's definition (e.g., <code>name</code>, <code>greeting</code>).</li>
        <li><strong>Arguments</strong> are the actual values passed to the function when it is called (e.g., <code>"Alice"</code>).</li>
        </ul>
        <p>The <code>return</code> statement exits the function and sends a value back to the caller. If there is no <code>return</code> statement, the function implicitly returns <code>None</code>.</p>
        <h3 id="advanced-argument-passing-args-kwargs">Advanced Argument Passing (*args, **kwargs)</h3>
        <p>These special syntaxes allow a function to accept a variable number of arguments.</p>
        <p><strong><code>*args</code> (Arbitrary Positional Arguments):</strong> When a parameter name is prefixed with <code>*</code>, it collects any "extra" positional arguments into a tuple. This allows you to pass any number of arguments.</p>
        <pre><code class="language-python">def calculate_sum(*args):
    """Calculates the sum of all numbers passed as arguments."""
    print(f"Arguments received as a tuple: {args}")
    total = 0
    for num in args:
        total += num
    return total

print(calculate_sum(1, 2, 3))       # Output: 6
print(calculate_sum(10, 20, 30, 40)) # Output: 100</code></pre>
        <p><strong><code>**kwargs</code> (Arbitrary Keyword Arguments):</strong> When a parameter name is prefixed with <code>**</code>, it collects any "extra" keyword arguments (e.g., <code>name="Alice"</code>) into a dictionary.</p>
        <pre><code class="language-python">def display_user_profile(**kwargs):
    """Displays user information passed as keyword arguments."""
    print(f"Arguments received as a dictionary: {kwargs}")
    for key, value in kwargs.items():
        print(f"{key.replace('_', ' ').title()}: {value}")

display_user_profile(username="ada_lovelace", first_name="Ada", last_name="Lovelace", field="Mathematics")</code></pre>
        <h3 id="lambda-anonymous-functions">Lambda (Anonymous) Functions</h3>
        <p>A lambda function is a small, one-line, anonymous function defined with the <code>lambda</code> keyword. It's a syntactic shortcut for simple functions.</p>
        <p><strong>Syntax:</strong> <code>lambda arguments: expression</code></p>
        <p>A lambda can have any number of arguments but only one expression. The expression is evaluated and its result is returned.</p>
        <pre><code class="language-python"># A regular function
def add(a, b):
    return a + b

# The equivalent lambda function
add_lambda = lambda a, b: a + b

print(f"From regular function: {add(5, 3)}") # Output: 8
print(f"From lambda function: {add_lambda(5, 3)}") # Output: 8</code></pre>
        <p>Lambdas are most commonly used when you need a simple function for a short period, often as an argument to a higher-order function like <code>sorted()</code>, <code>map()</code>, or <code>filter()</code>.</p>
        <pre><code class="language-python"># Sort a list of tuples by the second element
points = [(1, 5), (4, 2), (2, 8)]
points.sort(key=lambda p: p[1])
print(points) # Output: [(4, 2), (1, 5), (2, 8)]</code></pre>
        <h3 id="recursion-and-the-base-case">Recursion and the Base Case</h3>
        <p>Recursion is a programming technique where a function calls itself to solve a problem. This approach is often elegant for problems that can be broken down into smaller, self-similar sub-problems.</p>
        <p>Every recursive function must have two parts:</p>
        <ul>
        <li><strong>Base Case:</strong> A condition that stops the recursion. Without a base case, the function would call itself infinitely, leading to a <code>RecursionError</code>.</li>
        <li><strong>Recursive Step:</strong> The part of the function where it calls itself, typically with a modified argument that moves it closer to the base case.</li>
        </ul>
        <p>The classic example is calculating a factorial. The factorial of n (written as n!) is the product of all positive integers up to n. For example, 5! = 5 * 4 * 3 * 2 * 1 = 120. This can be defined recursively as <code>n! = n * (n-1)!</code>.</p>
        <pre><code class="language-python">def factorial(n):
    # Base Case: The factorial of 0 or 1 is 1. This stops the recursion.
    if n == 0 or n == 1:
        return 1
    # Recursive Step: The function calls itself with a smaller number (n-1).
    else:
        return n * factorial(n - 1)

print(f"The factorial of 5 is: {factorial(5)}") # Output: 120</code></pre>

        <h2 id="chapter-9-modules-packages-and-pip">Chapter 9: Modules, Packages, and pip</h2>
        <h3 id="understanding-and-creating-modules">Understanding and Creating Modules</h3>
        <p>As programs grow, it becomes essential to organize them. A <strong>module</strong> is simply a Python file (<code>.py</code>) containing definitions and statements. Modules allow you to group related code, making it more manageable and reusable across different projects.</p>
        <p>Let's create a simple module.</p>
        <p><code>utils.py</code>:</p>
        <pre><code class="language-python"># This file is a module named 'utils'

PI = 3.14159

def calculate_area(radius):
    """Calculates the area of a circle."""
    return PI * (radius ** 2)

def calculate_circumference(radius):
    """Calculates the circumference of a circle."""
    return 2 * PI * radius</code></pre>
        <h3 id="the-import-statement-variations">The import Statement Variations</h3>
        <p>To use the code from one module in another file, you use the <code>import</code> statement.</p>
        <p><code>main.py</code> (in the same directory as <code>utils.py</code>):</p>
        <pre><code class="language-python"># Variation 1: Import the entire module
# You must prefix the functions/variables with the module name.
import utils

area = utils.calculate_area(10)
print(f"Area: {area}")
print(f"Value of PI: {utils.PI}")

# Variation 2: Import specific components from a module
# This brings the names directly into the current scope.
from utils import calculate_circumference

circumference = calculate_circumference(10)
print(f"Circumference: {circumference}")

# Variation 3: Import with an alias
# This is useful for long module names or to avoid naming conflicts.
import utils as u

new_area = u.calculate_area(5)
print(f"New area: {new_area}")</code></pre>
        <h3 id="packages-and-__init__py">Packages and __init__.py</h3>
        <p>When a project becomes very large, you can group related modules into a directory. This directory is called a <strong>package</strong>. For Python to recognize a directory as a package, it must contain a special file named <code>__init__.py</code>. This file can be empty.</p>
        <p>This allows for a hierarchical structure, and you can import using dot notation.</p>
        <p>Example Structure:</p>
        <pre><code class="language-bash">my_project/
â”œâ”€â”€ main.py
â””â”€â”€ my_app/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ models.py
    â””â”€â”€ views.py</code></pre>
        <p>In <code>main.py</code>, you could then import from the package like this:</p>
        <pre><code class="language-python">from my_app import models
from my_app.views import render_homepage</code></pre>
        <h3 id="mastering-pip-the-package-manager">Mastering pip: The Package Manager</h3>
        <p>Python's true power comes from its vast ecosystem of third-party libraries available on the <strong>Python Package Index (PyPI)</strong>. <code>pip</code> is the command-line tool used to install and manage these packages.</p>
        <p><strong>Install a package:</strong></p>
        <pre><code class="language-bash">pip install requests</code></pre>
        <p><strong>Install a specific version</strong> (crucial for project reproducibility):</p>
        <pre><code class="language-bash">pip install "pandas==1.4.2"</code></pre>
        <p><strong>Upgrade a package:</strong></p>
        <pre><code class="language-bash">pip install --upgrade numpy</code></pre>
        <p><strong>Uninstall a package:</strong></p>
        <pre><code class="language-bash">pip uninstall requests</code></pre>
        <p><strong>List installed packages</strong> (in the current environment):</p>
        <pre><code class="language-bash">pip list</code></pre>
        <p><strong>Show package details</strong> (like version, dependencies, etc.):</p>
        <pre><code class="language-bash">pip show pandas</code></pre>
		        <div class="part-heading" id="part-2-intermediate-and-advanced-python">Part 2: Intermediate and Advanced Python</div>

        <h2 id="chapter-10-object-oriented-programming-oop">Chapter 10: Object-Oriented Programming (OOP)</h2>
        <p>Object-Oriented Programming is a programming paradigm based on the concept of "objects," which can contain both data (in the form of fields, often known as attributes or properties) and code (in the form of procedures, often known as methods). It allows you to model real-world things and the relationships between them in your code.</p>
        <h3 id="the-oop-paradigm-classes-and-objects">The OOP Paradigm: Classes and Objects</h3>
        <p>A <strong>Class</strong> is a blueprint or a template for creating objects. It defines a set of attributes that will characterize any object of the class, as well as a set of methods or operations that can be performed by such objects. For example, a <code>Car</code> class might define attributes like <code>color</code> and <code>model</code>, and methods like <code>start_engine()</code> and <code>drive()</code>.</p>
        <p>An <strong>Object</strong> is an instance of a class. It is a concrete entity created from the class blueprint. You can create many objects from the same class. For example, <code>my_blue_tesla</code> and <code>my_red_ford</code> could both be objects (instances) of the <code>Car</code> class.</p>
        <h3 id="the-__init__-constructor-and-instance-attributes">The __init__() Constructor and Instance Attributes</h3>
        <p>The <code>__init__()</code> method is a special method, often called a "constructor," that is automatically called when you create a new instance of a class. Its primary job is to initialize the object's instance-specific attributes.</p>
        <p>The first parameter of <code>__init__</code> (and any instance method) is always <code>self</code>. The <code>self</code> keyword is a reference to the current instance of the class. Python passes this argument automatically. You use <code>self</code> to access attributes and methods of the object.</p>
        <p><strong>Instance Attributes</strong> are data that belong to a specific object (instance). They are defined inside <code>__init__</code> by assigning values to <code>self.attribute_name</code>. Each object can have different values for its instance attributes.</p>
        <pre><code class="language-python">class Car:
    # The __init__ method is the constructor.
    def __init__(self, make, model, year):
        # These are instance attributes.
        # They are unique to each Car object.
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0 # An attribute with a default value
        print(f"A new {year} {make} {model} has been created.")

# Creating two different objects (instances) of the Car class
car_1 = Car("Honda", "Civic", 2021)
car_2 = Car("Ford", "Mustang", 2022)

# Accessing instance attributes
print(f"Car 1 is a {car_1.make} {car_1.model}.") # Output: Car 1 is a Honda Civic.
print(f"Car 2 is a {car_2.make} {car_2.model}.") # Output: Car 2 is a Ford Mustang.</code></pre>
        <h3 id="instance-methods-vs-class-attributes">Instance Methods vs. Class Attributes</h3>
        <p><strong>Instance Methods</strong> are functions defined inside a class that operate on the data (instance attributes) of an object. They always take <code>self</code> as their first parameter, allowing them to read and modify the object's state.</p>
        <p><strong>Class Attributes</strong> are attributes that are shared by all instances of the class. They belong to the class itself, not to any particular object. They are defined directly inside the class, outside of any method.</p>
        <pre><code class="language-python">class Car:
    # This is a CLASS attribute. It's shared by all instances of Car.
    wheels = 4

    def __init__(self, make, model, year):
        # These are INSTANCE attributes.
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    # This is an INSTANCE method. It operates on a specific object.
    def get_description(self):
        """Return a neatly formatted descriptive name."""
        return f"{self.year} {self.make} {self.model}"

    # Another instance method that modifies an instance attribute
    def drive(self, miles):
        """Increase the odometer reading by a given amount of miles."""
        if miles > 0:
            self.odometer_reading += miles
            print(f"Drove {miles} miles.")
        else:
            print("Cannot drive a negative distance!")

my_car = Car("Tesla", "Model 3", 2023)

# Calling an instance method
print(my_car.get_description()) # Output: 2023 Tesla Model 3

# Accessing the class attribute
print(f"My car has {my_car.wheels} wheels.") # Output: My car has 4 wheels.

# Modifying the object's state with an instance method
my_car.drive(50)
print(f"Odometer: {my_car.odometer_reading}") # Output: Odometer: 50</code></pre>

        <h2 id="chapter-11-advanced-oop-concepts">Chapter 11: Advanced OOP Concepts</h2>
        <h3 id="inheritance-and-the-super-method">Inheritance and the super() Method</h3>
        <p>Inheritance is a fundamental principle of OOP that allows a new class (the <strong>child class</strong> or derived class) to inherit attributes and methods from an existing class (the <strong>parent class</strong> or base class). This promotes code reuse and creates a logical hierarchy.</p>
        <p>The child class can use all the functionality of the parent class, and it can also <strong>override</strong> parent methods (provide its own implementation) or add new methods and attributes.</p>
        <p>The <code>super()</code> function is a special function that allows a child class to call methods from its parent class. This is especially useful for extending, rather than completely replacing, a parent's <code>__init__</code> or other methods.</p>
        <pre><code class="language-python"># Parent Class
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        return f"{self.name} makes a sound."

# Child Class inheriting from Animal
class Dog(Animal):
    def __init__(self, name, breed):
        # Use super() to call the parent's __init__ method.
        # This initializes the 'name' attribute from the parent.
        super().__init__(name)
        # Add a new attribute specific to the Dog class.
        self.breed = breed

    # Override the parent's speak method
    def speak(self):
        return f"{self.name} barks."

# Another Child Class
class Cat(Animal):
    # This class doesn't override speak(), so it will use the parent's version.
    pass

my_dog = Dog("Buddy", "Golden Retriever")
my_cat = Cat("Whiskers")

print(my_dog.speak()) # Output: Buddy barks. (Uses the overridden method)
print(my_dog.name)    # Output: Buddy (Inherited attribute from Animal)
print(my_dog.breed)   # Output: Golden Retriever (Dog-specific attribute)

print(my_cat.speak()) # Output: Whiskers makes a sound. (Uses the parent's method)</code></pre>
        <h3 id="class-methods-classmethod-static-methods-staticmethod">Class Methods (@classmethod) & Static Methods (@staticmethod)</h3>
        <p>While instance methods operate on an object (<code>self</code>), there are two other types of methods decorated to change their behavior.</p>
        <p>A <strong>Class Method</strong> is bound to the class, not the instance. It receives the class itself as the first argument, conventionally named <code>cls</code>. Class methods are often used as "factory methods" that can create instances of the class in alternative ways. They are defined using the <code>@classmethod</code> decorator.</p>
        <p>A <strong>Static Method</strong> does not receive any implicit first argument (<code>self</code> or <code>cls</code>). It is essentially a regular function that is namespaced inside a class because it is logically related to it. It cannot modify the object state or class state. It is defined using the <code>@staticmethod</code> decorator.</p>
        <pre><code class="language-python">class Pizza:
    def __init__(self, ingredients):
        self.ingredients = ingredients

    def __repr__(self):
        return f"Pizza({self.ingredients})"

    @classmethod
    def margherita(cls):
        """A factory method to create a margherita pizza."""
        # 'cls' refers to the Pizza class itself.
        return cls(['mozzarella', 'tomatoes'])

    @classmethod
    def prosciutto(cls):
        """A factory method to create a prosciutto pizza."""
        return cls(['mozzarella', 'tomatoes', 'prosciutto'])

    @staticmethod
    def is_vegetarian(ingredients):
        """A static method to check ingredients. It has no access to 'cls' or 'self'."""
        return "prosciutto" not in ingredients and "ham" not in ingredients

# Using the class methods as alternative constructors
margherita_pizza = Pizza.margherita()
print(margherita_pizza) # Output: Pizza(['mozzarella', 'tomatoes'])

# Using the static method directly from the class
print(Pizza.is_vegetarian(['mozzarella', 'mushrooms'])) # Output: True
print(Pizza.is_vegetarian(margherita_pizza.ingredients)) # Output: True</code></pre>
        <h3 id="operator-overloading-dunder-methods">Operator Overloading (Dunder Methods)</h3>
        <p>Python allows you to define how standard operators like <code>+</code>, <code>-</code>, <code>*</code>, <code>==</code>, and even functions like <code>len()</code> and <code>str()</code> work with your custom objects. This is achieved by implementing special methods, often called <strong>dunder methods</strong> (for double underscore).</p>
        <p>This makes your objects behave more intuitively and allows them to integrate seamlessly with Python's built-in syntax.</p>
        <pre><code class="language-python">class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # Defines the behavior for the '+' operator
    def __add__(self, other):
        """Returns a new Vector that is the sum of two vectors."""
        if not isinstance(other, Vector):
            return NotImplemented
        return Vector(self.x + other.x, self.y + other.y)

    # Defines the behavior for str() and print()
    def __str__(self):
        """User-friendly string representation."""
        return f"Vector({self.x}, {self.y})"

    # Defines the behavior for repr() and interactive display
    # Should be an unambiguous representation of the object
    def __repr__(self):
        """Developer-friendly string representation."""
        return f"Vector(x={self.x}, y={self.y})"

    # Defines the behavior for the '==' operator
    def __eq__(self, other):
        """Checks if two vectors are equal."""
        return self.x == other.x and self.y == other.y

v1 = Vector(2, 4)
v2 = Vector(3, 5)

# The __add__ method is called automatically
v3 = v1 + v2
print(v3) # The __str__ method is called: Vector(5, 9)

# The __eq__ method is called
print(v1 == Vector(2, 4)) # Output: True
print(v1 == v2)           # Output: False</code></pre>
        <h2 id="chapter-12-file-io-and-exception-handling">Chapter 12: File I/O and Exception Handling</h2>
        <h3 id="working-with-files-and-the-with-statement">Working with Files and the with Statement</h3>
        <p>File I/O (Input/Output) is the process of reading from and writing to files on your computer.</p>
        <p>The <code>open()</code> function is used to open a file and returns a file object. It takes two main arguments: the file path and the mode.</p>
        <ul>
            <li>'r': Read (default). Raises an error if the file doesn't exist.</li>
            <li>'w': Write. Creates a new file if it doesn't exist, or truncates (erases) the file if it does.</li>
            <li>'a': Append. Adds new content to the end of the file. Creates the file if it doesn't exist.</li>
            <li>'r+': Read and Write.</li>
        </ul>
        <p>It is crucial to always close a file after you are done with it to free up system resources. The <code>with</code> statement is the recommended way to work with files because it automatically handles closing the file, even if errors occur within the block.</p>
        <pre><code class="language-python"># Writing to a file using the 'with' statement
lines_to_write = ["First line.\n", "Second line.\n"]
with open("my_file.txt", "w") as f:
    f.write("This is a new file.\n")
    f.writelines(lines_to_write)
# The file is automatically closed here.

# Reading from a file
try:
    with open("my_file.txt", "r") as f:
        # .read() reads the entire file into one string
        # content = f.read()
        # print(content)
        
        # Or, iterate line by line (more memory-efficient for large files)
        for line in f:
            print(line.strip()) # .strip() removes the newline character
except FileNotFoundError:
    print("The file could not be found.")</code></pre>
        <h3 id="the-try-except-else-finally-block">The try...except...else...finally Block</h3>
        <p>Exception Handling is a mechanism for responding to runtime errors (exceptions) in a controlled way, preventing your program from crashing.</p>
        <ul>
            <li><strong><code>try</code>:</strong> The <code>try</code> block contains the code that might raise an exception.</li>
            <li><strong><code>except</code>:</strong> If an exception of a specific type occurs in the <code>try</code> block, the corresponding <code>except</code> block is executed. You can have multiple <code>except</code> blocks to handle different types of errors.</li>
            <li><strong><code>else</code>:</strong> The <code>else</code> block is optional and is executed only if no exceptions were raised in the <code>try</code> block.</li>
            <li><strong><code>finally</code>:</strong> The <code>finally</code> block is optional and is always executed, regardless of whether an exception occurred or not. It is typically used for cleanup actions, like closing a network connection.</li>
        </ul>
        <pre><code class="language-python">try:
    numerator = int(input("Enter a numerator: "))
    denominator = int(input("Enter a denominator: "))
    result = numerator / denominator
except ValueError:
    print("Invalid input. Please enter numbers only.")
except ZeroDivisionError:
    print("Error: Cannot divide by zero.")
else:
    # This runs only if the division was successful
    print(f"The result is {result}")
finally:
    # This runs no matter what
    print("Execution finished.")</code></pre>
        <h3 id="raising-and-creating-custom-exceptions">Raising and Creating Custom Exceptions</h3>
        <p>You can intentionally trigger an exception using the <code>raise</code> keyword. This is useful when a function's input is invalid according to its logic.</p>
        <p>You can also create your own custom exception classes by inheriting from Python's base <code>Exception</code> class. This makes your error handling more specific and descriptive.</p>
        <pre><code class="language-python"># Creating a custom exception
class InsufficientFundsError(Exception):
    """Custom exception raised when an account has insufficient funds."""
    pass

class BankAccount:
    def __init__(self, balance):
        self.balance = balance

    def withdraw(self, amount):
        if amount > self.balance:
            # Raising the custom exception
            raise InsufficientFundsError(f"Cannot withdraw ${amount}. Only ${self.balance} available.")
        self.balance -= amount
        return self.balance

# Using the class and handling the custom exception
account = BankAccount(100)
try:
    account.withdraw(500)
except InsufficientFundsError as e:
    print(f"Error handling withdrawal: {e}")
# Output: Error handling withdrawal: Cannot withdraw $500. Only $100 available.</code></pre>

        <h2 id="chapter-13-advanced-language-features">Chapter 13: Advanced Language Features</h2>
        <p>This chapter explores some of Python's more expressive and powerful features that can help you write more concise, readable, and efficient code.</p>
        <h3 id="comprehensions-list-set-dictionary">Comprehensions (List, Set, Dictionary)</h3>
        <p>Comprehensions provide a compact syntax for creating a new sequence or mapping by iterating over an existing one. They are often more readable and faster than using explicit <code>for</code> loops.</p>
        <h4>List Comprehension</h4>
        <p>The most common type, used to create lists.</p>
        <p><strong>Syntax:</strong> <code>[expression for item in iterable if condition]</code></p>
        <pre><code class="language-python"># Traditional way with a for loop
squares = []
for x in range(10):
    if x % 2 == 0: # Only for even numbers
        squares.append(x**2)
print(f"Traditional: {squares}")

# The equivalent list comprehension
squares_comp = [x**2 for x in range(10) if x % 2 == 0]
print(f"Comprehension: {squares_comp}")
# Output for both: [0, 4, 16, 36, 64]</code></pre>
        <h4>Set Comprehension</h4>
        <p>Similar to list comprehensions but creates a set, which automatically handles uniqueness.</p>
        <p><strong>Syntax:</strong> <code>{expression for item in iterable if condition}</code></p>
        <pre><code class="language-python"># Create a set of unique squared numbers from a list with duplicates
numbers = [1, 2, 2, 3, 3, 3, 4]
unique_squares = {x**2 for x in numbers}
print(unique_squares) # Output: {1, 4, 9, 16}</code></pre>
        <h4>Dictionary Comprehension</h4>
        <p>Creates a dictionary from an iterable.</p>
        <p><strong>Syntax:</strong> <code>{key_expression: value_expression for item in iterable if condition}</code></p>
        <pre><code class="language-python"># Create a dictionary mapping numbers to their squares
square_dict = {x: x**2 for x in range(5)}
print(square_dict) # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# Create a new dictionary by swapping keys and values
users = {'alice': 'admin', 'bob': 'editor', 'charlie': 'viewer'}
roles = {role: name for name, role in users.items()}
print(roles) # Output: {'admin': 'alice', 'editor': 'bob', 'viewer': 'charlie'}</code></pre>
        <h3 id="the-walrus-operator-colon-equals">The Walrus Operator (:=)</h3>
        <p>Introduced in Python 3.8, the assignment expression operator <code>:=</code>, affectionately known as the "walrus operator," allows you to assign a value to a variable as part of a larger expression. This can help avoid redundant computations and make some patterns, particularly in <code>while</code> loops, more concise.</p>
        <pre><code class="language-python"># Traditional way: reading lines from a file until an empty line is found
lines = []
while True:
    line = input("Enter a value (or press Enter to quit): ")
    if not line:
        break
    lines.append(line)
print(f"You entered: {lines}")


# With the walrus operator: assign and test in the same line
lines_walrus = []
while (line := input("Enter a value (or press Enter to quit): ")):
    lines_walrus.append(line)
print(f"You entered: {lines_walrus}")</code></pre>
        <p>In the walrus example, <code>line</code> is assigned the result of <code>input(...)</code>, and the value of that assignment (the content of <code>line</code>) is then tested by the <code>while</code> loop. The loop continues as long as <code>line</code> is not an empty string (which is a "falsy" value).</p>
        <h3 id="decorators">Decorators</h3>
        <p>A decorator is a special kind of function that takes another function as an argument, adds some functionality to it (or "decorates" it), and returns the modified function without permanently altering the original function's source code. This is a powerful concept from metaprogramming.</p>
        <p>The <code>@</code> syntax is syntactic sugar for applying a decorator.</p>
        <pre><code class="language-python">import time

# This is the decorator function. It takes a function as its argument.
def timing_decorator(func):
    # The wrapper function is what actually gets called.
    # *args and **kwargs ensure it can handle any function signature.
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}...")
        start_time = time.time()
        result = func(*args, **kwargs) # Call the original function
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time:.4f} seconds to run.")
        return result
    return wrapper

# Applying the decorator to a function
@timing_decorator
def slow_function(delay):
    """A function that simulates a long-running task."""
    time.sleep(delay)
    return "Task complete"

# When we call slow_function, we are actually calling the decorated 'wrapper' function.
output = slow_function(2)
print(output)
# Output:
# Calling slow_function...
# slow_function took 2.0021 seconds to run.
# Task complete</code></pre>
        <h3 id="generators-and-the-yield-keyword">Generators and the yield Keyword</h3>
        <p>A generator is a special kind of iterator, created by a function that uses the <code>yield</code> keyword. Unlike a regular function that computes all its results and returns them at once (e.g., in a list), a generator computes one result, yields it, and then pauses its execution, preserving its state. When the next result is requested, it resumes execution from where it left off.</p>
        <p>This "lazy evaluation" makes generators incredibly memory-efficient, especially for working with very large or infinite sequences.</p>
        <pre><code class="language-python"># A regular function that returns a list (stores all values in memory)
def get_squares_list(n):
    squares = []
    for i in range(n):
        squares.append(i**2)
    return squares

# A generator function using yield
def get_squares_generator(n):
    """Yields the square of numbers from 0 to n-1, one at a time."""
    for i in range(n):
        print(f"Yielding {i**2}")
        yield i**2

# Using the generator
# Note that no code inside the generator runs when you create it.
squares_gen = get_squares_generator(5)
print("Generator created.")

# The code inside the generator only runs when you iterate over it.
for square in squares_gen:
    print(f"Received {square}")

# Output:
# Generator created.
# Yielding 0
# Received 0
# Yielding 1
# Received 1
# Yielding 4
# Received 4
# Yielding 9
# Received 9
# Yielding 16
# Received 16</code></pre>
        <p>You can also create concise generator expressions, which look like list comprehensions but use parentheses.</p>
        <pre><code class="language-python">gen_expr = (x**2 for x in range(1000000)) # This uses almost no memory
# print(sum(gen_expr)) # The sum can be calculated without storing all million numbers at once</code></pre>
        <div class="part-heading" id="part-3-the-python-ecosystem-and-best-practices">Part 3: The Python Ecosystem and Best Practices</div>

        <h2 id="chapter-14-a-tour-of-the-standard-library">Chapter 14: A Tour of the Standard Library</h2>
        <p>Python's "batteries-included" philosophy means it comes with a rich and powerful standard library of modules that you can use without installing anything extra. This chapter provides a brief tour of some of the most essential modules.</p>
        <h3 id="os-and-sys-interacting-with-the-system">os and sys: Interacting with the System</h3>
        <p>The <code>os</code> module provides a way of using operating system dependent functionality, like reading or writing to the file system.</p>
        <p>The <code>sys</code> module provides access to system-specific parameters and functions, such as the command-line arguments passed to a script.</p>
        <pre><code class="language-python">import os
import sys

# os module examples
print(f"Current Working Directory: {os.getcwd()}")
# os.mkdir("new_folder") # Create a new directory

# list files and directories
print(f"Contents of current directory: {os.listdir('.')}")

# sys module examples
print(f"Python version: {sys.version}")
print(f"Command-line arguments: {sys.argv}") # sys.argv is a list of arguments</code></pre>
        <h3 id="datetime-working-with-dates-and-times">datetime: Working with Dates and Times</h3>
        <p>The <code>datetime</code> module supplies classes for manipulating dates and times.</p>
        <pre><code class="language-python">from datetime import datetime, timedelta

# Get the current date and time
now = datetime.now()
print(f"Now: {now}")

# Create a specific date
some_day = datetime(year=2025, month=1, day=1)
print(f"Some day: {some_day}")

# Formatting dates into strings using strftime()
print(f"Formatted: {now.strftime('%Y-%m-%d %H:%M:%S')}") # e.g., 2023-10-27 14:30:00

# Performing date arithmetic with timedelta
one_week_from_now = now + timedelta(weeks=1)
print(f"One week from now: {one_week_from_now}")</code></pre>
        <h3 id="math-and-random-numerical-operations">math and random: Numerical Operations</h3>
        <p>The <code>math</code> module provides access to mathematical functions for floating-point numbers.</p>
        <p>The <code>random</code> module implements pseudo-random number generators for various distributions.</p>
        <pre><code class="language-python">import math
import random

# math module
print(f"Value of Pi: {math.pi}")
print(f"Square root of 81: {math.sqrt(81)}") # Output: 9.0
print(f"Ceiling of 4.3: {math.ceil(4.3)}")   # Output: 5

# random module
# A random integer between 1 and 10 (inclusive)
random_int = random.randint(1, 10)
print(f"Random integer: {random_int}")

# A random floating point number between 0.0 and 1.0
random_float = random.random()
print(f"Random float: {random_float}")

# Choose a random element from a list
choices = ['rock', 'paper', 'scissors']
my_choice = random.choice(choices)
print(f"Random choice: {my_choice}")</code></pre>
        <h3 id="json-working-with-json-data">json: Working with JSON Data</h3>
        <p>The <code>json</code> module allows you to encode Python objects into a JSON (JavaScript Object Notation) formatted string and decode JSON strings back into Python objects. This is essential for working with web APIs.</p>
        <ul>
        <li><code>json.dumps()</code>: Dumps a Python object (like a dict or list) to a JSON string.</li>
        <li><code>json.loads()</code>: Loads a Python object from a JSON string.</li>
        </ul>
        <pre><code class="language-python">import json

# Python dictionary
python_dict = {
    "name": "John Doe",
    "age": 30,
    "isStudent": False,
    "courses": [
        {"title": "History", "credits": 3},
        {"title": "Math", "credits": 4}
    ]
}

# Convert Python dict to JSON string
json_string = json.dumps(python_dict, indent=4) # indent makes it readable
print("--- JSON String ---")
print(json_string)

# Convert JSON string back to Python dict
recreated_dict = json.loads(json_string)
print("\n--- Recreated Python Dict ---")
print(recreated_dict)
print(f"Name from recreated dict: {recreated_dict['name']}")</code></pre>
        <h3 id="re-an-introduction-to-regular-expressions">re: An Introduction to Regular Expressions</h3>
        <p>The <code>re</code> module provides support for regular expressions, which are powerful mini-languages for finding and manipulating complex patterns in strings.</p>
        <ul>
        <li><code>re.search(pattern, string)</code>: Scans through a string, looking for the first location where the pattern produces a match.</li>
        <li><code>re.findall(pattern, string)</code>: Finds all non-overlapping matches of a pattern in a string and returns them as a list of strings.</li>
        </ul>
        <pre><code class="language-python">import re

text = "My email is user@example.com, and my friend's is friend.name@work.co.uk"

# A simple pattern to find email addresses
email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'

# Find all matches
emails = re.findall(email_pattern, text)
print(f"Found emails: {emails}")
# Output: Found emails: ['user@example.com', 'friend.name@work.co.uk']</code></pre>
        <h3 id="collections-advanced-data-structures">collections: Advanced Data Structures</h3>
        <p>The <code>collections</code> module provides high-performance alternatives to Python's general-purpose built-in containers (dict, list, set, and tuple).</p>
        <ul>
        <li><strong><code>Counter</code></strong>: A subclass of dict for counting hashable objects.</li>
        <li><strong><code>defaultdict</code></strong>: A subclass of dict that calls a factory function to supply missing values.</li>
        <li><strong><code>deque</code></strong>: A list-like container with fast appends and pops from both ends.</li>
        </ul>
        <pre><code class="language-python">from collections import Counter, defaultdict

# Counter example
word_list = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']
word_counts = Counter(word_list)
print(word_counts) # Output: Counter({'apple': 3, 'banana': 2, 'orange': 1})
print(f"Most common: {word_counts.most_common(1)}") # Output: [('apple', 3)]

# defaultdict example
# Avoids KeyError when accessing a key for the first time
char_locations = defaultdict(list)
word = "hello"
for index, char in enumerate(word):
    char_locations[char].append(index)

print(char_locations)
# Output: defaultdict(<class 'list'>, {'h': [0], 'e': [1], 'l': [2, 3], 'o': [4]})
print(char_locations['l']) # Output: [2, 3]
print(char_locations['z']) # Output: [] (no KeyError, returns default empty list)</code></pre>
        <h2 id="chapter-15-exploring-the-python-ecosystem">Chapter 15: Exploring the Python Ecosystem</h2>
        <p>While Python's standard library is powerful, its true strength lies in the vast ecosystem of third-party libraries available on the Python Package Index (PyPI). This chapter provides a high-level overview of the most popular domains where Python excels and the key libraries used.</p>
        <h3 id="web-development-flask-django-and-requests">Web Development: Flask, Django, and requests</h3>
        <p>Python is a top choice for building everything from simple web APIs to complex, data-driven websites.</p>
        <ul>
            <li><strong><code>requests</code>:</strong> The de-facto standard library for making HTTP requests. If you need to fetch data from a web API or scrape a website, <code>requests</code> makes it simple and elegant.</li>
        </ul>
        <pre><code class="language-python">import requests
response = requests.get('https://api.github.com/users/python')
print(response.json()['name']) # Output: Python Software Foundation</code></pre>
        <ul>
            <li><strong>Flask:</strong> A "micro-framework" for web development. It provides the bare essentials for building a web application, giving you the flexibility to choose your own tools and libraries. It's excellent for APIs, small projects, and developers who want more control.</li>
            <li><strong>Django:</strong> A "batteries-included," high-level framework. It comes with a vast amount of built-in functionality, including an ORM (Object-Relational Mapper) for database interactions, an admin panel, and an authentication system. It's designed for rapid development of secure and maintainable websites.</li>
        </ul>
        <h3 id="data-science-numpy-pandas-and-matplotlib">Data Science: NumPy, Pandas, and Matplotlib</h3>
        <p>Python is the dominant language in data science and machine learning due to its powerful and intuitive libraries.</p>
        <ul>
            <li><strong>NumPy (Numerical Python):</strong> The fundamental package for numerical computing. It introduces the powerful <code>ndarray</code> object, a multi-dimensional array that is far more efficient for numerical operations than standard Python lists.</li>
            <li><strong>Pandas:</strong> Built on top of NumPy, Pandas provides high-performance, easy-to-use data structuresâ€”primarily the <code>DataFrame</code>â€”and data analysis tools. It is the essential tool for cleaning, transforming, manipulating, and analyzing structured data.</li>
            <li><strong>Matplotlib:</strong> The foundational plotting library in the Python ecosystem. It provides a huge amount of control for creating static, animated, and interactive visualizations like line charts, bar graphs, histograms, and scatter plots.</li>
        </ul>
        <h3 id="scripting-automation">Scripting & Automation</h3>
        <p>This is often where developers first fall in love with Python. Its clear syntax and powerful standard library (<code>os</code>, <code>shutil</code>, <code>re</code>, <code>subprocess</code>) make it perfect for automating repetitive tasks, such as:</p>
        <ul>
            <li>Renaming and organizing files.</li>
            <li>Scraping data from websites.</li>
            <li>Interacting with APIs to generate reports.</li>
            <li>Automating system administration tasks.</li>
        </ul>
        <h3 id="concurrency-an-overview-of-threading-multiprocessing-asyncio">Concurrency: An Overview of threading, multiprocessing, asyncio</h3>
        <p>Concurrency allows a program to work on multiple tasks at the same time. Python provides several approaches, each suited for different problems.</p>
        <ul>
            <li><strong><code>threading</code>:</strong> Runs multiple threads (lighter-weight "processes") within the same process. Because of the GIL (see Chapter 17), threads are best for <strong>I/O-bound</strong> tasks, like waiting for network requests or reading from a file, where the program would otherwise be idle.</li>
            <li><strong><code>multiprocessing</code>:</strong> Runs multiple processes, each with its own Python interpreter and memory space. This allows it to sidestep the GIL and achieve true parallelism on multi-core CPUs, making it ideal for <strong>CPU-bound</strong> tasks, like heavy mathematical computations.</li>
            <li><strong><code>asyncio</code>:</strong> A framework for writing single-threaded concurrent code using coroutines (<code>async</code>/<code>await</code> syntax). It's a form of cooperative multitasking where tasks voluntarily yield control when they are waiting for I/O. It is extremely efficient for high-performance network applications that need to handle thousands of simultaneous connections.</li>
        </ul>

        <h2 id="chapter-16-professional-workflows-tools">Chapter 16: Professional Workflows & Tools</h2>
        <p>Writing code is only one part of software development. Professional workflows and tools ensure that your code is reliable, maintainable, and collaborative.</p>
        <h3 id="virtual-environments-and-dependency-management">Virtual Environments and Dependency Management</h3>
        <p>A virtual environment is an isolated Python environment that allows you to manage dependencies for a specific project separately, preventing conflicts between projects that might require different versions of the same library.</p>
        <p><strong>Create an environment:</strong></p>
        <pre><code class="language-bash">python -m venv my_project_env</code></pre>
        <p><strong>Activate the environment:</strong></p>
        <ul>
            <li>On macOS/Linux: <code>source my_project_env/bin/activate</code></li>
            <li>On Windows: <code>my_project_env\Scripts\activate</code></li>
        </ul>
        <p><strong>Manage Dependencies:</strong></p>
        <p>It is standard practice to list a project's dependencies in a <code>requirements.txt</code> file.</p>
        <ul>
            <li>Generate the file: <code>pip freeze > requirements.txt</code></li>
            <li>Install from the file on another machine: <code>pip install -r requirements.txt</code></li>
        </ul>
        <h3 id="the-importance-of-if-__name__-main">The Importance of if __name__ == '__main__'</h3>
        <p>This conditional block is a cornerstone of reusable Python code. It allows a script to be both runnable directly and importable as a module in another script.</p>
        <ul>
            <li>When you run a script directly (<code>python my_script.py</code>), the special built-in variable <code>__name__</code> is set to the string <code>"__main__"</code>.</li>
            <li>When you import a script as a module (<code>import my_script</code>), <code>__name__</code> is set to the module's name (in this case, "my_script").</li>
        </ul>
        <pre><code class="language-python">def main_function():
    """Contains the primary logic of the script."""
    print("This script is being run directly.")

def utility_function():
    """A helper function that might be useful elsewhere."""
    return "This is a utility."

# This check ensures the code inside only runs when the script is executed directly.
if __name__ == "__main__":
    main_function()</code></pre>
        <h3 id="debugging-pdb-and-ide-debuggers">Debugging: pdb and IDE Debuggers</h3>
        <ul>
            <li><strong><code>pdb</code> (Python Debugger):</strong> A built-in, interactive source code debugger for the command line. You can set a breakpoint anywhere in your code by inserting this line: <code>import pdb; pdb.set_trace()</code>. When the code runs, it will pause at that point and give you an interactive prompt to inspect variables and step through the code.</li>
            <li><strong>IDE Debuggers:</strong> Modern IDEs like VS Code and PyCharm have powerful graphical debuggers that are much more user-friendly. They allow you to set breakpoints by clicking in the margin, step through code line-by-line (Step Over, Step Into), inspect the call stack, and watch variable values change in real-time.</li>
        </ul>
        <h3 id="testing-unittest-and-pytest">Testing: unittest and pytest</h3>
        <p>Writing automated tests is crucial for ensuring your code works as expected and continues to work as you make changes.</p>
        <ul>
            <li><strong><code>unittest</code>:</strong> Python's built-in testing framework. It is based on the xUnit style common in other languages.</li>
            <li><strong><code>pytest</code>:</strong> A popular third-party framework that has become the de-facto standard. It makes writing tests simpler and more readable with less boilerplate code and has a rich ecosystem of plugins.</li>
        </ul>
        <h3 id="linting-and-formatting-flake8-and-black">Linting and Formatting: Flake8 and Black</h3>
        <ul>
            <li><strong>Linter (Flake8):</strong> A tool that analyzes your code for potential errors, bugs, and stylistic issues according to the PEP 8 style guide (the official style guide for Python code). Running a linter helps you write cleaner, more professional code.</li>
            <li><strong>Formatter (Black):</strong> An "uncompromising code formatter." Black automatically reformats your Python code to a consistent style. This saves an enormous amount of time and completely eliminates arguments about formatting within a team.</li>
        </ul>
        <h3 id="version-control-with-git">Version Control with Git</h3>
        <p>Git is the most widely used version control system. It is an essential tool for any developer. It allows you to:</p>
        <ul>
            <li>Track the history of every change made to your code.</li>
            <li>Revert to previous versions if a bug is introduced.</li>
            <li>Work on new features in isolated "branches" without affecting the main codebase.</li>
            <li>Collaborate with other developers on the same project seamlessly.</li>
        </ul>
        <p>Learning basic Git commands (<code>git add</code>, <code>git commit</code>, <code>git push</code>, <code>git pull</code>, <code>git branch</code>) is fundamental.</p>
		        <h2 id="chapter-17-a-glimpse-into-pythons-internals">Chapter 17: A Glimpse into Python's Internals</h2>
        <h3 id="the-global-interpreter-lock-gil">The Global Interpreter Lock (GIL)</h3>
        <p>The GIL is a mutex (a lock) that protects access to Python objects, preventing multiple native threads from executing Python bytecodes at the same time within a single process. This means that even on a multi-core processor, only one thread can be executing Python code at any given moment. This design choice simplifies memory management and makes integrating C libraries easier, but it limits parallelism for CPU-bound tasks. This is why the <code>multiprocessing</code> module is used for true CPU-bound parallelism.</p>
        <h3 id="garbage-collection">Garbage Collection</h3>
        <p>Python uses automatic garbage collection to manage memory, so developers don't have to manually allocate and deallocate memory. The primary mechanism is reference counting. Every object keeps a count of how many variables reference it. When this count drops to zero, the object's memory is immediately freed. A secondary, cyclic garbage collector also runs periodically to find and clean up objects that reference each other in a cycle (and are thus unreachable), which reference counting alone cannot handle.</p>
        <h3 id="descriptors-and-metaclasses">Descriptors and Metaclasses</h3>
        <p>These are advanced topics for deep metaprogramming that underpin much of Python's functionality.</p>
        <ul>
            <li><strong>Descriptors:</strong> A protocol that allows objects to customize attribute access, redirection, and deletion by implementing <code>__get__</code>, <code>__set__</code>, and <code>__delete__</code> methods. Properties, which are created with the <code>@property</code> decorator, are a common and simple use of descriptors.</li>
            <li><strong>Metaclasses:</strong> The "class of a class." Just as a class is a blueprint for creating objects, a metaclass is a blueprint for creating classes. They allow you to intercept the creation of a class to modify it, which is used in advanced frameworks like Django's ORM.</li>
        </ul>

        <h2 id="bonus-chapter-vs-code-productivity-tips">Bonus Chapter: VS Code Productivity Tips</h2>
        <div class="card">
            <p>Visual Studio Code is a powerful editor, and mastering a few shortcuts can dramatically increase your coding speed. Here are some of the most useful features for Python development.</p>
            <ul>
                <li><strong>Command Palette (<code>Ctrl+Shift+P</code> or <code>Cmd+Shift+P</code>):</strong> This is your most important tool. It gives you access to every command in VS Code. If you forget a shortcut, open the Command Palette and type what you want to do (e.g., "format document").</li>
                <li><strong>Multi-Cursor Editing:</strong>
                    <ul>
                        <li><strong>Add Cursor Above/Below (<code>Ctrl+Alt+Up/Down</code> or <code>Cmd+Opt+Up/Down</code>):</strong> Place cursors on multiple lines to edit them all at once.</li>
                        <li><strong>Add Cursor at Click (<code>Alt+Click</code>):</strong> Hold Alt (or Opt on Mac) and click anywhere to add a new cursor.</li>
                        <li><strong>Select Next Match (<code>Ctrl+D</code> or <code>Cmd+D</code>):</strong> Select the current word, then press Ctrl+D again to select the next occurrence of that word, creating a new cursor at each match.</li>
                    </ul>
                </li>
                <li><strong>Line Manipulation:</strong>
                    <ul>
                        <li><strong>Copy Line Down/Up (<code>Shift+Alt+Down/Up</code> or <code>Shift+Opt+Down/Up</code>):</strong> Quickly duplicate the current line above or below.</li>
                        <li><strong>Move Line Up/Down (<code>Alt+Up/Down</code> or <code>Opt+Up/Down</code>):</strong> Move the entire current line up or down.</li>
                        <li><strong>Delete Line (<code>Ctrl+Shift+K</code> or <code>Cmd+Shift+K</code>):</strong> Delete the current line without needing to select it first.</li>
                    </ul>
                </li>
                <li><strong>Code Formatting:</strong>
                    <ul>
                        <li><strong>Format Document (<code>Shift+Alt+F</code> or <code>Shift+Opt+F</code>):</strong> Automatically format your entire Python file using the configured formatter (e.g., Black).</li>
                    </ul>
                </li>
                <li><strong>Navigation:</strong>
                    <ul>
                        <li><strong>Go to File (<code>Ctrl+P</code> or <code>Cmd+P</code>):</strong> Quickly open any file in your project by typing its name.</li>
                        <li><strong>Go to Symbol in File (<code>Ctrl+Shift+O</code> or <code>Cmd+Shift+O</code>):</strong> See an outline of all functions and classes in the current file and jump to one.</li>
                    </ul>
                </li>
                <li><strong>Integrated Terminal (<code>Ctrl+`</code> or <code>Cmd+`</code>):</strong> Open or close the built-in terminal without leaving the editor. This is perfect for running your scripts, managing Git, and using pip.</li>
                <li><strong>Rename Symbol (<code>F2</code>):</strong> Click on a variable or function name, press F2, and type the new name. VS Code will intelligently refactor and rename all instances of that symbol within its scope.</li>
            </ul>
        </div>
    <!-- ====================================================== -->
<!--                  START OF NEW CONTENT                  -->
<!-- ====================================================== -->

<div class="part-heading" id="part-4-building-real-applications">Part 4: Building Real-World Applications</div>

<!-- CHAPTER 18: DATABASES -->
<h2 id="chapter-18-interacting-with-databases">Chapter 18: Interacting with Databases</h2>
<p>Nearly all complex applications need to store data persistently. This chapter covers how your Python applications can communicate with databases, the standard for managing structured information.</p>

<h3 id="intro-sql-vs-nosql">Introduction to SQL vs. NoSQL</h3>
<p>Databases primarily come in two flavors. <strong>SQL databases</strong> (like PostgreSQL or SQLite) are relational, storing data in tables with a predefined schema. <strong>NoSQL databases</strong> (like MongoDB) are non-relational and often store data in flexible formats like JSON-like documents.</p>

<h3 id="using-the-sqlite3-module">The Built-in <code>sqlite3</code> Module</h3>
<p>Python includes a built-in module for working with SQLite, a lightweight, file-based database. It's perfect for learning and for smaller applications.</p>
<pre><code class="language-python">
import sqlite3
# Create or connect to a database file
conn = sqlite3.connect("my_app.db")
cursor = conn.cursor()

# Create a table
cursor.execute("""
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL
)
""")

# Insert data
cursor.execute("INSERT INTO users (name, email) VALUES (?, ?)", ("Aarush", "aarush@example.com"))
conn.commit() # Save changes

# Query data
cursor.execute("SELECT * FROM users")
print(cursor.fetchall())

conn.close()
</code></pre>

<h3 id="orms-and-sqlalchemy">Introduction to ORMs and SQLAlchemy</h3>
<p>An Object-Relational Mapper (ORM) allows you to interact with your database using Python objects instead of writing raw SQL. <strong>SQLAlchemy</strong> is the most popular ORM in the Python ecosystem.</p>
<pre><code class="language-python">
# This is a conceptual example of using an ORM
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    email = Column(String)

engine = create_engine('sqlite:///my_app.db')
Session = sessionmaker(bind=engine)
session = Session()

# Create a user object and add it to the database
new_user = User(name="Harry", email="harry@example.com")
session.add(new_user)
session.commit()
</code></pre>
<!-- CHAPTER 19: WEB APIS -->
<h2 id="chapter-19-web-development-building-a-practical-rest-api">Chapter 19: Web Development: Building a Practical REST API</h2>
<p>REST APIs are the backbone of the modern web, allowing different applications to communicate. Python, with frameworks like Flask and FastAPI, is a top choice for building them.</p>

<h3 id="api-fundamentals">API Fundamentals</h3>
<p>A REST API consists of endpoints (URLs) that respond to HTTP methods. Common methods include <code>GET</code> (to retrieve data), <code>POST</code> (to create data), <code>PUT</code> (to update data), and <code>DELETE</code> (to remove data). Data is typically exchanged in JSON format.</p>

<h3 id="building-an-api-with-fastapi">Building an API with FastAPI</h3>
<p><strong>FastAPI</strong> is a modern, high-performance web framework for building APIs with Python. It includes automatic data validation and interactive documentation.</p>
<pre><code class="language-python">
# main.py - Run with: uvicorn main:app --reload
from fastapi import FastAPI
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    price: float
    is_offer: bool = None

app = FastAPI()

@app.get("/")
def read_root():
    return {"Hello": "World"}

@app.post("/items/")
def create_item(item: Item):
    # FastAPI automatically validates the incoming data
    return {"item_name": item.name, "price": item.price}
</code></pre>
<p>After running this, you can visit <code>http://127.0.0.1:8000/docs</code> in your browser to see the interactive API documentation.</p>
<!-- CHAPTER 20: DATA SCIENCE -->
<h2 id="chapter-20-practical-data-science-analysis-and-visualization">Chapter 20: Practical Data Science: Analysis and Visualization</h2>
<p>This chapter walks through a mini-project using Pandas for data analysis and Matplotlib for visualization, two cornerstones of the Python data science ecosystem.</p>

<h3 id="loading-and-cleaning-data">Loading and Cleaning Data with Pandas</h3>
<p>The Pandas <code>DataFrame</code> is the central data structure for data analysis. We can load data from various sources, like a CSV file, and begin exploring it.</p>
<pre><code class="language-python">
import pandas as pd

# Assuming you have a 'sales.csv' file
# with columns: 'Date', 'Product', 'Revenue'
df = pd.read_csv('sales.csv')

print(df.head()) # Show the first 5 rows
print(df.info()) # Show a summary, including data types and missing values
</code></pre>

<h3 id="data-manipulation-and-visualization">Data Manipulation and Visualization</h3>
<p>Once loaded, we can filter, group, and aggregate the data to answer questions. We can then use Matplotlib to visualize the results.</p>
<pre><code class="language-python">
import matplotlib.pyplot as plt

# Convert 'Date' column to datetime objects
df['Date'] = pd.to_datetime(df['Date'])

# Find total revenue per product
revenue_by_product = df.groupby('Product')['Revenue'].sum()
print(revenue_by_product)

# Plot the results
revenue_by_product.plot(kind='bar', title='Total Revenue by Product')
plt.ylabel('Total Revenue')
plt.show() # Display the plot
</code></pre>
<!-- CHAPTER 21: DEPLOYMENT -->
<h2 id="chapter-21-professional-deployment-docker-ci-cd">Chapter 21: Professional Deployment: Docker and CI/CD</h2>
<p>Writing code is just the first step. Professional developers use tools like Docker and CI/CD to package and automatically test their applications for reliable deployment.</p>

<h3 id="packaging-with-docker">Packaging with Docker</h3>
<p>A <code>Dockerfile</code> is a text file with instructions on how to build a container image for your application. This makes your app portable and ensures it runs the same way everywhere.</p>
<pre><code class="language-bash">
# Dockerfile
# Use an official Python runtime as a parent image
FROM python:3.9-slim

# Set the working directory in the container
WORKDIR /app

# Copy the dependencies file and install them
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy the rest of your application's code
COPY . .

# Command to run your application
CMD ["python", "your_app.py"]
</code></pre>

<h3 id="automating-with-github-actions">Automating with GitHub Actions (CI/CD)</h3>
<p>Continuous Integration (CI) is the practice of automatically running checks like tests and linters every time you push code. A workflow file in your project's <code>.github/workflows/</code> directory can automate this.</p>
<pre><code class="language-yaml">
# .github/workflows/python-ci.yml
name: Python CI

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v3
        with:
          python-version: '3.9'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run linter
        run: |
          pip install flake8
          flake8 .
      - name: Run tests
        run: |
          pip install pytest
          pytest
</code></pre>
<!-- CHAPTER 22: GUI PT. 1 -->
<h2 id="chapter-22-gui-development-pt-1-fundamentals-and-interaction">Chapter 22: GUI Development Pt. 1 - Fundamentals and Interaction</h2>
<p>This chapter introduces GUI development using Python's built-in <strong>Tkinter</strong> library, taking you from a blank screen to a simple, interactive application.</p>

<h3 id="windows-widgets-and-the-grid">Windows, Widgets, and the Grid</h3>
<p>Every GUI application has a root window and widgets arranged within it. The <code>.grid()</code> manager is a powerful way to organize widgets in rows and columns.</p>
<pre><code class="language-python">
import tkinter as tk

window = tk.Tk()
window.title("Greeter App")

# Create widgets
greeting_label = tk.Label(window, text="Enter your name:")
name_entry = tk.Entry(window)
greet_button = tk.Button(window, text="Greet Me")

# Arrange widgets on the grid
greeting_label.grid(row=0, column=0, padx=10, pady=10)
name_entry.grid(row=0, column=1, padx=10, pady=10)
greet_button.grid(row=1, column=0, columnspan=2, pady=10)

window.mainloop() # Start the event loop
</code></pre>

<h3 id="event-handling-and-state">Event Handling and State</h3>
<p>To make the application do something, we link the button's `command` to a Python function. This function reads from one widget (the `Entry`) and updates another (a `Label`).</p>
<pre><code class="language-python">
# ... (setup code from above) ...

def greet_user():
    name = name_entry.get()
    result_text = f"Hello, {name}!"
    result_label.config(text=result_text)

# Update the button to link it to the function
greet_button.config(command=greet_user)

# Add a new label for the result
result_label = tk.Label(window, text="")
result_label.grid(row=2, column=0, columnspan=2, pady=10)

window.mainloop()
</code></pre>
<!-- CHAPTER 23: GUI PT. 2 -->
<h2 id="chapter-23-gui-development-pt-2-professional-structure-and-widgets">Chapter 23: GUI Development Pt. 2 - Professional Structure and Widgets</h2>
<p>For larger applications, structuring your code with classes is essential. This chapter covers refactoring to OOP and using more advanced, modern-looking widgets.</p>

<h3 id="structuring-with-oop-and-frames">Structuring with OOP and Frames</h3>
<p>By making our application a class that inherits from `tk.Frame`, we can keep our code organized and reusable.</p>
<pre><code class="language-python">
import tkinter as tk
from tkinter import ttk # Import themed widgets

class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Structured App")
        
        # Use a themed frame
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill="both", expand=True)

        # Create and place widgets inside the frame
        self.name_label = ttk.Label(main_frame, text="Name:")
        self.name_label.pack()

if __name__ == "__main__":
    app = App()
    app.mainloop()
</code></pre>

<h3 id="displaying-data-with-treeview">Displaying Data with Treeview</h3>
<p>The `ttk.TreeView` widget is perfect for displaying tabular data, like file information or database records.</p>
<pre><code class="language-python">
# Conceptual example within an App class
columns = ('#1', '#2', '#3')
self.tree = ttk.TreeView(self, columns=columns, show='headings')

self.tree.heading('#1', text='First Name')
self.tree.heading('#2', text='Last Name')
self.tree.heading('#3', text='Email')

# Add some data
contacts = [('Aarush', 'Maurya', 'a@m.com'), ('Harry', 'Code', 'h@c.com')]
for contact in contacts:
    self.tree.insert('', tk.END, values=contact)

self.tree.pack()
</code></pre>
<!-- CHAPTER 24: GUI PT. 3 -->
<h2 id="chapter-24-gui-development-pt-3-polishing-and-distribution">Chapter 24: GUI Development Pt. 3 - Polishing and Distribution</h2>
<p>The final chapter covers how to handle slow operations without freezing your app and how to package it for others to use.</p>

<h3 id="handling-long-running-tasks">Handling Long-Running Tasks with Threading</h3>
<p>If a function takes a long time to run (e.g., downloading a file), it will freeze the GUI. We can use the `threading` module to run such tasks in the background.</p>
<pre><code class="language-python">
import time
import threading

def slow_task():
    print("Starting slow task...")
    time.sleep(5) # Simulate a long operation
    print("Slow task finished.")

# In your button's command function:
def on_button_click():
    # Create and start a new thread to run the slow task
    thread = threading.Thread(target=slow_task)
    thread.start()
</code></pre>

<h3 id="distributing-your-app-with-pyinstaller">Distributing Your App with PyInstaller</h3>
<p>PyInstaller is a tool that analyzes your Python script and bundles it with all its dependencies into a single executable file that can be run on other computers, even if they don't have Python installed.</p>
<pre><code class="language-bash">
# 1. Install PyInstaller
pip install pyinstaller

# 2. Navigate to your script's directory in the terminal

# 3. Run PyInstaller to create a single executable
# The --onefile flag creates a single .exe file
# The --windowed flag prevents the console from opening on run
pyinstaller --onefile --windowed your_gui_app.py
</code></pre>
<p>After running, you will find your application inside a new `dist` folder.</p>

<!-- ====================================================== -->
<!--                   END OF NEW CONTENT                   -->
<!-- ====================================================== -->    
    </main>

    <!-- Prism.js Core & Component Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <!-- Custom Script -->
    <script src="script.js"></script>
</body>
</html>